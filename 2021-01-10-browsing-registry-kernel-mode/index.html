<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content=BlahCats name=author><meta content="Tales of a binary encoded life..." name=description><meta prefix="og: http://ogp.me/ns#" content=BlahCats property=og:site_name><meta prefix="og: http://ogp.me/ns#" content=blog property=og:type><meta content="Browsing the registry in kernel-mode" prefix="og: http://ogp.me/ns#" property=og:title><meta content="Browsing the registry in kernel-mode - by hugsy" prefix="og: http://ogp.me/ns#" property=og:description><meta prefix="og: http://ogp.me/ns#" content=en_US property=og:locale><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/2021-01-10-browsing-registry-kernel-mode property=og:url><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/img/950bbc05-e57e-4d49-96a4-9aefec9a8ef6.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=@ctf_blahcat name=twitter:site><meta content=BlahCats name=twitter:title><meta content="Browsing the registry in kernel-mode - by hugsy" name=twitter:description><meta content=https://blahcat.github.io/2021-01-10-browsing-registry-kernel-mode name=twitter:url><meta content=https://blahcat.github.io/img/950bbc05-e57e-4d49-96a4-9aefec9a8ef6.png name=twitter:image:src><script type=application/ld+json>
    {
      "@context" : "http://schema.org",
      "@type" : "Website",
      "name": " BlahCats",
      "url" : "https://blahcat.github.io/2021-01-10-browsing-registry-kernel-mode",
      
      "image": https://blahcat.github.io/img/950bbc05-e57e-4d49-96a4-9aefec9a8ef6.png",
      
      
      "description": Browsing the registry in kernel-mode - by hugsy",
      
    }
    </script><title>
  Browsing the registry in kernel-mode
</title><link href=https://blahcat.github.io/img/favicon.ico rel=icon type=image/x-icon><link href=https://blahcat.github.io/css/bootstrap.min.css rel=stylesheet><link href=" https://blahcat.github.io/css/all.min.css" rel=" stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Montserrat:400,300" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lato" -- <!-- custom for rel=stylesheet styles template this><link href=https://blahcat.github.io/css/clean-blog.css rel=stylesheet><link href=https://blahcat.github.io/css/overrides.css rel=stylesheet><link integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css referrerpolicy=no-referrer rel=stylesheet><body><nav class="navbar navbar-expand-lg navbar-light fixed-top" id=mainNav><div class=container><a class=navbar-brand href=https://blahcat.github.io>BlahCats Blog</a><button aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right" aria-controls=navbarResponsive aria-expanded=false data-target=#navbarResponsive data-toggle=collapse type=button>Menu <i class="fas fa-bars"></i></button><div class="collapse navbar-collapse" id=navbarResponsive><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://blahcat.github.io>Home</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/series>Series</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/notes>Notes</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/about>About</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/qemu>Qemu VMs</a></ul></div></div></nav><header class=masthead style=background-image:url(https://blahcat.github.io/img/950bbc05-e57e-4d49-96a4-9aefec9a8ef6.png)><div class=overlay></div><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><div class=post-heading><h1>Browsing the registry in kernel-mode</h1><span class=meta> <b> ‚Ä¢ <a href=/author/hugsy>hugsy</a> ‚Ä¢ </b> 10 January 2021 <br> <br> <i>Reading time: 19 min</i> </span></div></div></div></div></header><article><article class=post><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><p>One of Windows kernel subsystem I recently dug into is the Configuration Manager (<abbr title="Configuration Manager">CM</abbr>), mostly because I found very scarce public resources about it despite its criticality: this subsystem is responsible for managing the configuration of all Windows resources, and in user-land is exposed via a very familiar mechanism, the <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users target=_blank>Windows Registry</a>. It is a pretty well documented <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows/win32/sysinfo/registry target=_blank>user-land mechanism</a>, and so is its <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows-hardware/drivers/install/registry-trees-and-keys target=_blank>kernel driver API</a>. My curiosity was around its inner working, and all the few (but brilliant) resources can be found in the link section below.<p>What I wondered was: How is the registry handled in the kernel by the <abbr title="Configuration Manager">CM</abbr>? So in the same way that I explored <a href=/2020/06/14/playing_with_self_reference_pml4_entry/>other</a> <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/windbg_js_scripts/blob/master/scripts/VadExplorer.js target=_blank>Windows</a> <a href=/2019/01/30/playing-with-windows-root-directory-object/>subsystems</a>, I tried to keep a practical approach, and the result was this WinDbg Js script, <code>RegistryExplorer.js</code> <sup class=footnote-reference id=fr-0-1><a href=#fn-0>[1]</a></sup> that‚Äôll be referring to throughout this post. This script allows to browse and query via LINQ the registry in a kernel debugging session.<div class=alert-info markdown=span><b class=markdown-alert-title> <svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" aria-hidden=true height=16 version=1.1 width=16><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg> Note </b><p><p>This is a collection of notes, do not blindly trust, assume mistakes. Also, you‚Äôll find the KD commands are given to reproduce easily, but your offset/index may vary. Last, everything was done/tested against Windows 10 x64 1909: I assume those findings to be applicable to other versions, but it may not be the case.</div><h2 id=overview>Overview</h2><p>The Registry consists of a set of regular structures called ‚ÄúHives‚Äù. Off-memory, they live in regular file (usually but not necessarily suffixed as <code>.dat</code> - ex: <code>%USERPROFILE%\NTUSER.dat</code>). Each <code>.dat</code> file operates as a small File System with its own hierarchy and nomenclature:<ul><li><strong>Registry</strong>: Collection of (2) Hives (+ metadata) ‚Üí <code>PRIMARY</code> + <code>.LOG</code><li><strong>Hive</strong>: Collection of Bins (+ metadata), follows a tree structure<li><strong>Bin</strong>: Collection of Cells (+ metadata), bin size must be aligned to <code>PAGE_SIZE</code><li><strong>Cell</strong>: Basic unit of allocation for the registry (contains raw data). The Cell size is declared as the 1st ULONG of the memory area. Those are critical, we‚Äôll develop how below.</ul><p>As a tree, a <strong>Hive</strong> can be browsed, exposing:<ul><li><strong>Keys</strong> (or <strong>Key Nodes</strong>), comparable to Directories in the traditional FS world<li><strong>Values</strong> (comparable to Files), each of which can have one of <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_key_value_basic_information target=_blank>12 types</a>: <code>REG_NONE</code>, <code>REG_SZ</code>, <code>REG_EXPAND_SZ</code>, <code>REG_BINARY</code>, <code>REG_DWORD_LITTLE_ENDIAN</code>, <code>REG_DWORD</code>, <code>REG_DWORD_BIG_ENDIAN</code>, <code>REG_LINK</code>, <code>REG_MULTI_SZ</code>, <code>REG_RESOURCE_LIST</code>, <code>REG_FULL_RESOURCE_DESCRIPTOR</code>, <code>REG_RESOURCE_REQUIREMENTS_LIST</code>, <code>REG_QWORD_LITTLE_ENDIAN</code>, <code>REG_QWORD</code></ul><p>Therefore a Key can contain Sub-Keys but also Values, just like a folder can contain sub-folders and files. Later on, we‚Äôll explain how to enumerate them, as we must go over some pre-requisites first. It could be noted that the analogy of a typical File System is true to the point where it is possible to abuse some situations via Symbolic Links (exploiting <code>REG_LINK</code> types) but we won‚Äôt be covering that today.<div class=alert-success markdown=span><b class=markdown-alert-title> <svg class="octicon octicon-light-bulb mr-2" viewbox="0 0 16 16" aria-hidden=true height=16 version=1.1 width=16><path d="M8 1.5c-2.363 0-4 1.69-4 3.75 0 .984.424 1.625.984 2.304l.214.253c.223.264.47.556.673.848.284.411.537.896.621 1.49a.75.75 0 0 1-1.484.211c-.04-.282-.163-.547-.37-.847a8.456 8.456 0 0 0-.542-.68c-.084-.1-.173-.205-.268-.32C3.201 7.75 2.5 6.766 2.5 5.25 2.5 2.31 4.863 0 8 0s5.5 2.31 5.5 5.25c0 1.516-.701 2.5-1.328 3.259-.095.115-.184.22-.268.319-.207.245-.383.453-.541.681-.208.3-.33.565-.37.847a.751.751 0 0 1-1.485-.212c.084-.593.337-1.078.621-1.489.203-.292.45-.584.673-.848.075-.088.147-.173.213-.253.561-.679.985-1.32.985-2.304 0-2.06-1.637-3.75-4-3.75ZM5.75 12h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1 0-1.5ZM6 15.25a.75.75 0 0 1 .75-.75h2.5a.75.75 0 0 1 0 1.5h-2.5a.75.75 0 0 1-.75-.75Z"></path></svg> Tip </b><p><p>For convenience, the following equivalence will be used throughout this post:<ul><li>Top-Level Keys = Root Keys<li>Sub Keys = Keys (as long as they aren‚Äôt Root Keys)</ul></div><p>The best structure definition of a Hive I could find comes from ‚ÄúWindows Kernel Internals NT Registry Implementation‚Äù<sup class=footnote-reference id=fr-1-1><a href=#fn-1>[2]</a></sup> (you‚Äôll find many references to the PDF in this post).</p><a href=/img/950bbc05-e57e-4d49-96a4-9aefec9a8ef6.png target=_blank> <img alt="Hive Layout" title="Hive Layout" src=/img/950bbc05-e57e-4d49-96a4-9aefec9a8ef6.png width=100%> </a><p>Some hives are loaded very early in the boot process, as the <abbr title="Boot Configuration Database">BCD</abbr> needs to retrieve its configuration settings from it in the <abbr title="Boot Configuration Database">CM</abbr> hive; and also during kernel loading, hardware info are exposed from the <code>HARDWARE</code> hive. Once parsed and loaded from file to memory, all the system hives are linked via a <code>LIST_ENTRY</code> whose head is pointed by the exposed symbol <code>nt!CmpHiveListHead</code>, and can be iterated over as a list of <code>nt!_CMHIVE</code> object using the <code>nt!_CMHIVE.HiveList</code> field. Therefore a quick parsing can be done with our best friends WinDbg + DDM, which allows us to do some LINQ magic:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dx -s @$hives = Debugger.Utility.Collections.FromListEntry(*(nt!_LIST_ENTRY*)&nt!CmpHiveListHead,"nt!_CMHIVE","HiveList")
</span><span>
</span><span>0: kd> dx @$hives.Count()
</span><span>@$hives.Count()  : 0x1f
</span><span>
</span><span>0: kd> dx -g @$hives.Select( x => new { CmHiveAddress= &x, HiveName=x.HiveRootPath} )
</span><span>====================================================================================================
</span><span>=           = (+) CmHiveAddress     = (+) HiveName                                                 =
</span><span>====================================================================================================
</span><span>= [0x0]     - 0xffffa70284240000    - ""                                                           =
</span><span>= [0x1]     - 0xffffa702842d2000    - "\REGISTRY\MACHINE\SYSTEM"                                   =
</span><span>= [0x2]     - 0xffffa70284340000    - "\REGISTRY\MACHINE\HARDWARE"                                 =
</span><span>= [0x3]     - 0xffffa70284d14000    - "\REGISTRY\MACHINE\BCD00000000"                              =
</span><span>= [0x4]     - 0xffffa70284cec000    - "\REGISTRY\MACHINE\SOFTWARE"                                 =
</span><span>= [0x5]     - 0xffffa702848e3000    - "\REGISTRY\USER\.DEFAULT"                                    =
</span><span>= [0x6]     - 0xffffa70287c43000    - "\REGISTRY\MACHINE\SECURITY"                                 =
</span><span>= [0x7]     - 0xffffa70287d46000    - "\REGISTRY\MACHINE\SAM"                                      =
</span><span>= [0x8]     - 0xffffa7028806a000    - "\REGISTRY\USER\S-1-5-20"                                    =
</span><span>[...]
</span></code></pre><p>which looks <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows/win32/sysinfo/predefined-keys target=_blank>familiar</a>. This command exposes all the <code>_CMHIVE</code> objects loaded by the kernel, but hives themselves can be manipulated via their handle of type <code>_HHIVE</code> (accessible from <code>nt!_CMHIVE.Hive</code>) which allows, thanks to callback members (i.e. function pointers in the structure), to declare how to get access to data, allocate/free new nodes, etc.<h2 id=accessing-the-registry>Accessing the registry</h2><p>An essential pre-requisite to understand how values are accessed in the kernel, is to understand 2 critical structures: <code>Cells</code> and <code>Key Nodes</code> (for now).<p>According to ‚ÄúWindows Kernel Internals NT Registry Implementation‚Äù<sup class=footnote-reference id=fr-1-2><a href=#fn-1>[2]</a></sup>, a <code>Cell</code> (p.12) is:<ul><li>The unit of storage allocation within the hive [‚Ä¶]<li>Used to store raw data, and build up logical data <ul><li>Keys, values, security descriptors, indexes etc all are made up of cells<li>Fetching in a key, might involve several faults spread across the hive file</ul></ul><p>A <code>Key Node</code> (of internal type <code>nt!_CM_KEY_NODE</code>) is the structure inside the tree that will allow to access Cells (don‚Äôt worry Cells will be amply covered below - for now just think of it as the raw data). For a given key node, its Values (~files) are pointed by the field <code>nt!_CM_KEY_NODE.ValueList</code>, of type <code>nt!_CHILD_LIST</code>; and its subkeys (~sub-folders) via <code>nt!_CM_KEY_NODE.SubkeyLists</code>. This is always true, except for symbolic links (type = <code>REG_LINK</code>), which will dereference the node they point to via the field <code>nt!_CM_KEY_NODE.ChildHiveReference</code>.<p>So when by browsing a key node, what to pay attention to are:<ul><li>the SubKey list (i.e. ~<em>subfolders</em>)</ul><pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dt _CM_KEY_NODE
</span><span>nt!_CM_KEY_NODE
</span><span>   [...]
</span><span>   +0x014 SubKeyCounts     : [2] Uint4B
</span><span>   +0x01c SubKeyLists      : [2] Uint4B
</span><span>   [...]
</span></code></pre><ul><li>the Value list (i.e. ~<em>files</em>)</ul><pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dt _CM_KEY_NODE
</span><span>nt!_CM_KEY_NODE
</span><span>  [...]
</span><span>   +0x024 ValueList        : _CHILD_LIST
</span><span>  [...]
</span><span>
</span><span>0: kd> dt _CHILD_LIST
</span><span>nt!_CHILD_LIST
</span><span>   +0x000 Count            : Uint4B
</span><span>   +0x004 List             : Uint4B
</span></code></pre><p>And looking up a specific Value can be summarized as such:<p><a href=//i.imgur.com/VpAuNWf.png target=_blank> <img alt="Lookup of value `Foo`" title="Lookup of value `Foo`" src=//i.imgur.com/VpAuNWf.png width=100%> </a> Source<sup class=footnote-reference id=fr-1-3><a href=#fn-1>[2]</a></sup><p>As we see from the symbols, Value and SubKey lists are not designated by direct pointers in memory, but instead by indexes. Those indexes point to Cells, which contains either the data itself or the next key node to parse to reach the data. We‚Äôve kept mentioning <code>Cells</code> without covering it, it now becomes important to do so, know how Cells are, how they work and how they can be accessed.<h3 id=cells>Cells</h3><p>The <code>Cell</code> is the basic storage unit for a Hive: what this means is that <strong>all data</strong> of the hive can be found by knowing 2 pieces of information, a handle to the hive (<code>_HHIVE</code>) and the <strong>Cell Index</strong> - a Cell is never pointed to directly. In the PDF by Dr B. Probert, a good technical overview of cells can be found, and the key points are:<ul><li>Referenced as a ‚Äòcell index‚Äô (HCELL_INDEX)<li>Cell index is offset within the file (minus 0x1000 ‚Äì the header) ‚Äì ULONG<li>Size rounded at 8 bytes boundary<li>If Index & 1<&LT31 , then the cell is Volatile ; Else Permanent<li>If Cell.Size >= 0 , Cell.Status = Free ; Else Cell.Status = Allocated && Cell.RealSize = -Cell.Size</ul><p>As for the exact type, <a rel="noopener nofollow noreferrer" href=https://doxygen.reactos.org/dc/dea/hivedata_8h.html#a3e41dc3c52fdf05ef049ec92af899d03 target=_blank>ReactOS</a> helps us with the exact definition:<pre class=language-c++ data-lang=c++ style=color:#c0c5ce;background-color:#2b303b><code class=language-c++ data-lang=c++><span>    </span><span style=color:#b48ead>typedef </span><span>ULONG HCELL_INDEX, *PHCELL_INDEX;
</span></code></pre><p>So the cell index is a ULONG, which can be decomposed as a bitmask that allows to determine more information such as the cell Type (Permanent vs Volatile) and the Block; information which can be extracted from the Index as such:<pre class=language-c++ data-lang=c++ style=color:#c0c5ce;background-color:#2b303b><code class=language-c++ data-lang=c++><span>    </span><span style=color:#b48ead>#define </span><span style=color:#8fa1b3>HvGetCellType</span><span>(</span><span style=color:#bf616a>Cell</span><span>)  ((ULONG)(((Cell) & HCELL_TYPE_MASK) >> HCELL_TYPE_SHIFT))
</span><span>    </span><span style=color:#b48ead>#define </span><span style=color:#8fa1b3>HvGetCellBlock</span><span>(</span><span style=color:#bf616a>Cell</span><span>) ((ULONG)(((Cell) & HCELL_BLOCK_MASK) >> HCELL_BLOCK_SHIFT))
</span></code></pre><p><a rel="noopener nofollow noreferrer" href=https://doxygen.reactos.org/dc/dea/hivedata_8h.html#a34144dc0721aacfbaacdaefdc4945e97 target=_blank>ReactOS</a><p>Now how do we go from the key node to a cell, assuming we have a hive handle and an index? Remember above when we mentioned that the procedure to get to the cell is a function pointer inside the hive handle: <code>nt!_HHIVE.GetCellRoutine</code>? Well, that‚Äôs how. Also interestingly, all the hive handles are pointing to the same function <code>nt!HvpGetCellPaged</code>, although it doesn‚Äôt have to be the case:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dt _HHIVE
</span><span>nt!_HHIVE
</span><span>   +0x000 Signature        : Uint4B    // 0xbee0bee0
</span><span>   +0x008 GetCellRoutine   : Ptr64     _CELL_DATA*
</span><span>   +0x010 ReleaseCellRoutine : Ptr64     void
</span><span>   +0x018 Allocate         : Ptr64     void*
</span><span>   +0x020 Free             : Ptr64     void
</span><span>   [...]
</span><span>
</span><span>0: kd> dx -g @$hives.Select( h => new { HiveName=h.HiveRootPath, CellRoutine=h.Hive.GetCellRoutine} )
</span><span>====================================================================================================
</span><span>=           = (+) HiveName                                                 = (+) CellRoutine       =
</span><span>====================================================================================================
</span><span>= [0x0]     - ""                                                           - 0xfffff8054248e880    =
</span><span>= [0x1]     - "\REGISTRY\MACHINE\SYSTEM"                                   - 0xfffff8054248e880    =
</span><span>= [0x2]     - "\REGISTRY\MACHINE\HARDWARE"                                 - 0xfffff8054248e880    =
</span><span>= [0x3]     - "\REGISTRY\MACHINE\SOFTWARE"                                 - 0xfffff8054248e880    =
</span><span>= [0x4]     - "\REGISTRY\MACHINE\BCD00000000"                              - 0xfffff8054248e880    =
</span><span>[...]
</span><span>
</span><span>0: kd> .printf "%y\n", 0xfffff8054248e880
</span><span>nt!HvpGetCellPaged (fffff805`4248e880)
</span></code></pre><p>By reversing it in IDA, it reveals the exact behavior for fetching cells (below shown in a simplified pseudo-C code):<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span>_CELL_DATA *__fastcall </span><span style=color:#8fa1b3>HvpGetCellPaged</span><span>(_HHIVE *</span><span style=color:#bf616a>hive</span><span>, </span><span style=color:#b48ead>unsigned int </span><span style=color:#bf616a>CellIndex</span><span>, _HV_GET_CELL_CONTEXT *</span><span style=color:#bf616a>ctx</span><span>)
</span><span>{
</span><span>  _HMAP_ENTRY *Entry;
</span><span>  PVOID BinAddress;
</span><span>  PVOID CellAddress;
</span><span>  _CELL_DATA *CellResult;
</span><span>  [...]
</span><span>  Entry = &hive->Storage[CellIndex >> </span><span style=color:#d08770>31</span><span>].</span><span style=color:#bf616a>Map</span><span>->Directory[(CellIndex >> </span><span style=color:#d08770>21</span><span>) & </span><span style=color:#d08770>0x3FF</span><span>]->Table[(CellIndex >> </span><span style=color:#d08770>12</span><span>) & </span><span style=color:#d08770>0x1FF</span><span>];
</span><span>  BinAddress = Entry->PermanentBinAddress;
</span><span>  [...]
</span><span>  CellAddress = Entry->BlockOffset + (BinAddress & </span><span style=color:#d08770>0xFFFFFFFFFFFFFFF0</span><span style=color:#2b303b;background-color:#bf616a>ui64</span><span>) + (CellIndex & </span><span style=color:#d08770>0xFFF</span><span>);
</span><span>  [...]
</span><span>  CellResult = (_CELL_DATA *)(CellAddress + </span><span style=color:#d08770>4</span><span>); </span><span style=color:#65737e>// *CellAddress contains the size field as ULONG
</span><span>  [...]
</span><span>  </span><span style=color:#b48ead>return</span><span> CellResult;
</span><span>}
</span></code></pre><p>With that in mind, we can craft an equivalent function <code>GetCellAddress</code> that we can use in WinDbg, which given a hive handle and an index will return the cell address in memory (in WinDbg JS):<pre class=language-javascript data-lang=javascript style=color:#c0c5ce;background-color:#2b303b><code class=language-javascript data-lang=javascript><span style=color:#b48ead>function </span><span style=color:#8fa1b3>GetCellAddress</span><span>(</span><span style=color:#bf616a>KeyHive</span><span>, </span><span style=color:#bf616a>Index</span><span>)
</span><span>{
</span><span>    </span><span style=color:#b48ead>let </span><span style=color:#bf616a>Type </span><span>= </span><span style=color:#8fa1b3>GetCellType</span><span>(</span><span style=color:#ebcb8b>Index</span><span>);
</span><span>    </span><span style=color:#b48ead>let </span><span style=color:#bf616a>Table </span><span>= </span><span style=color:#8fa1b3>GetCellTable</span><span>(</span><span style=color:#ebcb8b>Index</span><span>);
</span><span>    </span><span style=color:#b48ead>let </span><span style=color:#bf616a>Block </span><span>= </span><span style=color:#8fa1b3>GetCellBlock</span><span>(</span><span style=color:#ebcb8b>Index</span><span>);
</span><span>    </span><span style=color:#b48ead>let </span><span style=color:#bf616a>Offset </span><span>= </span><span style=color:#8fa1b3>GetCellOffset</span><span>(</span><span style=color:#ebcb8b>Index</span><span>);
</span><span>    </span><span style=color:#b48ead>let </span><span style=color:#bf616a>MapDirectory </span><span>= </span><span style=color:#bf616a>KeyHive</span><span>.</span><span style=color:#bf616a>Storage</span><span>[</span><span style=color:#bf616a>Type</span><span>].</span><span style=color:#bf616a>Map</span><span>;
</span><span>    </span><span style=color:#b48ead>let </span><span style=color:#bf616a>MapTableEntry </span><span>= </span><span style=color:#bf616a>MapDirectory</span><span>.</span><span style=color:#bf616a>Directory</span><span>[</span><span style=color:#bf616a>Table</span><span>];
</span><span>    </span><span style=color:#b48ead>let </span><span style=color:#bf616a>Entry </span><span>= </span><span style=color:#bf616a>host</span><span>.</span><span style=color:#8fa1b3>createPointerObject</span><span>(</span><span style=color:#bf616a>MapTableEntry</span><span>.</span><span style=color:#bf616a>address</span><span>.</span><span style=color:#96b5b4>add</span><span>(</span><span style=color:#bf616a>Block </span><span>* </span><span style=color:#8fa1b3>sizeof</span><span>("</span><span style=color:#a3be8c>nt!_HMAP_ENTRY</span><span>")), "</span><span style=color:#a3be8c>nt</span><span>", "</span><span style=color:#a3be8c>_HMAP_ENTRY*</span><span>");
</span><span>    </span><span style=color:#b48ead>let </span><span style=color:#bf616a>BinAddress </span><span>= </span><span style=color:#ebcb8b>Entry</span><span>.</span><span style=color:#bf616a>PermanentBinAddress</span><span>.</span><span style=color:#8fa1b3>bitwiseAnd</span><span>(~</span><span style=color:#d08770>0x0f</span><span>);
</span><span>    </span><span style=color:#b48ead>let </span><span style=color:#bf616a>CellAddress </span><span>= </span><span style=color:#bf616a>BinAddress</span><span>.</span><span style=color:#96b5b4>add</span><span>(</span><span style=color:#ebcb8b>Entry</span><span>.</span><span style=color:#bf616a>BlockOffset</span><span>).</span><span style=color:#96b5b4>add</span><span>(</span><span style=color:#bf616a>Offset</span><span>);
</span><span>    </span><span style=color:#b48ead>return </span><span style=color:#bf616a>CellAddress</span><span>;
</span><span>}
</span></code></pre><p>Such function is critical to navigate correctly in the hive, and we‚Äôll refer to it in the rest of the article as <code>GetCellAddress()</code>. If you remember the lookup slide, you‚Äôll realize that the function is ‚Äúincorrect‚Äù: in its state it‚Äôll return the address of the beginning of the Cell, which holds the size (as a ULONG). Therefore to get the address of the <strong>data</strong> of the Cell, simply add <code>sizeof(ULONG)</code> (or 4) to the result.<p>It was interesting to me to find that the engineers behind the CM have decided to go with this function pointer approach for hives, instead of a static one but couldn‚Äôt find one (if you know, let me know!). And hey, it makes any form of kernel hooking for the registry a lot easier so it‚Äôs great for us!<h3 id=enumerating-values>Enumerating Values</h3><p>Now that we‚Äôve understood the logic behind Cells and how to navigate through them, the rest is easier to understand. As we‚Äôve mentioned before, ‚ÄúKey Values‚Äù are roughly the equivalent of a regular filesystem files. To get the values of a specific key node, one can use the field <code>nt!_CM_KEY_NODE.ValueList</code> (of type <code>_CHILD_LIST</code>) we‚Äôve briefly discussed above.<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dt _CHILD_LIST
</span><span>nt!_CHILD_LIST
</span><span>   +0x000 Count            : Uint4B
</span><span>   +0x004 List             : Uint4B
</span></code></pre><p>Then it‚Äôs as simple as it gets: the structure gives us the number of values and the Cell Index of the array (of the form of an array of size <code>_CHILD_LIST.Count</code> x <code>sizeof(HCELL_INDEX)</code>) of all the values of this key node. Then we simply iterate through the list of HCELL_INDEX using <code>GetCellAddress(KeyHive, Index)</code> to get the Key Nodes of type <code>CM_KEY_VALUE_SIGNATURE</code>: the type <code>CM_KEY_VALUE_SIGNATURE</code> will indicate that the current node has a structure of <code>nt!_CM_KEY_VALUE</code>, where the actual content and content length can be read.<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dt _CM_KEY_VALUE
</span><span>nt!_CM_KEY_VALUE
</span><span>   +0x000 Signature        : Uint2B
</span><span>   +0x002 NameLength       : Uint2B
</span><span>   +0x004 DataLength       : Uint4B
</span><span>   +0x008 Data             : Uint4B
</span><span>   +0x00c Type             : Uint4B
</span><span>   +0x010 Flags            : Uint2B
</span><span>   +0x012 Spare            : Uint2B
</span><span>   +0x014 Name             : [1] Wchar
</span></code></pre><p><code>_CM_KEY_VALUE.Data</code> doesn‚Äôt contain a pointer to the data, but again an <code>HCELL_INDEX</code>: so we need to call again <code>GetCellAddress()</code> on this index (we stay on the same hive), and finally retrieve the data.<h3 id=enumerating-subkeys>Enumerating SubKeys</h3><p>By knowing how cells work it is possible to know how subkeys will be linked: subkeys are just <code>_CM_KEY_NODE</code> objects. the structure gives 2 fields<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>   +0x014 SubKeyCounts     : [2] Uint4B
</span><span>   +0x01c SubKeyLists      : [2] Uint4B
</span></code></pre><p>The important one is <code>SubKeyLists</code> which is an array of 2 (‚Ä¶ you guessed it ‚Ä¶) Cell Indexes (<code>HCELL_INDEX</code>). The reasons each array has 2 entries, is to differentiate between Permanent SubKeys (at index 0), and Volatile subKeys (at index 1). To iterate through a tree, there needs to be a root. And the hive root node cell index is given by the field <code>RootCell</code> of the <code>_HBASE_BLOCK</code>, which the hive handle always holds a reference to, via the <code>BaseBlock</code> field:<div class=mermaid>graph LR; A[_HHIVE] -- ".BaseBlock" --> B["_HBASE_BLOCK"]; B -- "GetCellAddress(.RootCell)" --> C["_CM_INDEX[0]"]; B -- "GetCellAddress(.RootCell)" --> E["_CM_INDEX[1]"]; B -- "GetCellAddress(.RootCell)" --> F["_CM_INDEX[...]"]; C -- ".Cell" --> D["_CM_KEY_NODE"];</div><p>As we shown before from the linked list of <code>_CMHIVE</code> from <code>nt!CmpHiveListHead</code> we can iterate through all the system hives. Each hive object has a pointer to a handle of hive (<code>_HHIVE</code>) which exposes a <code>_DUAL</code> field named <code>Storage</code>: the index 0 is used for permanent storage, index 1 for volatile<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dt _DUAL
</span><span>nt!_DUAL
</span><span>   +0x000 Length           : Uint4B
</span><span>   +0x008 Map              : Ptr64 _HMAP_DIRECTORY
</span><span>   +0x010 SmallDir         : Ptr64 _HMAP_TABLE
</span><span>   +0x018 Guard            : Uint4B
</span><span>   +0x020 FreeDisplay      : [24] _FREE_DISPLAY
</span><span>   +0x260 FreeBins         : _LIST_ENTRY
</span><span>   +0x270 FreeSummary      : Uint4B
</span></code></pre><p>To summarize more graphically<div class=mermaid>graph LR; Z(nt!CmpHiveListHead) --> X["_CMHIVE"]; X-- ".Hive" --> Y["_HHIVE"]; Y-- ".Storage[0=Permanent,1=Volatile]" --> W[_HMAP_DIRECTORY]</div><p>The subkeys will be located in the <code>Map</code> element (of type <code>_HMAP_DIRECTORY</code>). The <code>_HMAP_DIRECTORY</code> structure simply contains 1 element, a table of 1024 <code>_HMAP_TABLE</code>, each of them structured of 1 element: a <code>Table</code> of 512 <code>_HMAP_ENTRY</code>.<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dt _HMAP_DIRECTORY
</span><span>nt!_HMAP_DIRECTORY
</span><span>   +0x000 Directory        : [1024] Ptr64 _HMAP_TABLE
</span><span>0: kd> dt _HMAP_TABLE
</span><span>nt!_HMAP_TABLE
</span><span>   +0x000 Table            : [512] _HMAP_ENTRY
</span><span>0: kd> dt _HMAP_ENTRY
</span><span>nt!_HMAP_ENTRY
</span><span>   +0x000 BlockOffset      : Uint8B
</span><span>   +0x008 PermanentBinAddress : Uint8B
</span><span>   +0x010 MemAlloc         : Uint4B
</span></code></pre><div class=mermaid>graph LR; A[_HMAP_DIRECTORY] --> B["_HMAP_TABLE[0]"]; A[_HMAP_DIRECTORY] --> C["_HMAP_TABLE[1]"]; A[_HMAP_DIRECTORY] --> D["_HMAP_TABLE[..]"]; A[_HMAP_DIRECTORY] --> E["_HMAP_TABLE[1023]"]; B --> F["_HMAP_ENTRY[0]"]; B --> G["_HMAP_ENTRY[1]"]; B --> H["_HMAP_ENTRY[..]"]; B --> I["_HMAP_ENTRY[511]"];</div><p>The last nibble of <code>PermanentBinAddress</code> is used for meta-data, so we can bitwise AND it with <code>~0xf</code>. Finally to access the data, we simply must add the BlockOffset value, and the final Offset retrieved from AND-ing the Index to 0xfff. This is a the behavior that the function <code>GetCellAddress()</code> will do for us to painlessly get the virtual address of a cell, just from a hive handle and an Index.<h2 id=put-it-all-together>Put it all together</h2><p>As a learning exercise, I always try to build a script/tool when digging into a topic, and here the result is another WinDbg JS script, <code>RegistryExplorer.js</code><sup class=footnote-reference id=fr-0-2><a href=#fn-0>[1]</a></sup> which will allow to navigate through the registry using WinDbg Debugger Data Model (and therefore also query it via LINQ)</p><a href=/img/5787cef5-11cc-4a1f-97b7-2f6533812b2d.png target=_blank> <img alt=image_alt src=/img/5787cef5-11cc-4a1f-97b7-2f6533812b2d.png title=image_alt width=100%> </a><div class=alert-info markdown=span><b class=markdown-alert-title> <svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" aria-hidden=true height=16 version=1.1 width=16><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg> Note </b><p><p>a better version was done by <a class="fab fa-twitter" href=https://twitter.com/msuiche target=_blank> <code>@msuiche</code> </a> here[^3]</div><p>Example:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dx @$cursession.Registry.Hives
</span><span>@$cursession.Registry.Hives                 : [object Generator]
</span><span>    [0x0]            : \REGISTRY\MACHINE\SYSTEM
</span><span>    [0x1]            : \REGISTRY\MACHINE\HARDWARE
</span><span>    [0x2]            : \REGISTRY\MACHINE\BCD00000000
</span><span>    [0x3]            : \REGISTRY\MACHINE\SOFTWARE
</span><span>    [0x4]            : \REGISTRY\USER\.DEFAULT
</span><span>    [0x5]            : \REGISTRY\MACHINE\SECURITY
</span><span>    [...]
</span><span>
</span><span>0: kd> dx @$cursession.Registry.Hives.Where( x => x.Name == "HARDWARE" ).First()
</span><span>@$cursession.Registry.Hives.Where( x => x.Name == "HARDWARE" ).First()             : \REGISTRY\MACHINE\HARDWARE
</span><span>    HiveObject       [Type: _CMHIVE]
</span><span>    HiveHandle       [Type: _HHIVE]
</span><span>    HiveAddress      : 0xffffcf0289744000
</span><span>    MountPoint       : \REGISTRY\MACHINE\HARDWARE
</span><span>    RootCellIndex    : 0x20
</span><span>    RootNode         : HARDWARE
</span><span>    Name             : HARDWARE
</span></code></pre><p>Or the click-friendly version üòÄ</p><a href=/img/0a76e279-63a2-4643-8f1f-bd3c877323d8.png target=_blank> <img alt=RegistryExplorer.js src=/img/0a76e279-63a2-4643-8f1f-bd3c877323d8.png title=RegistryExplorer.js width=100%> </a><h3 id=practical-toy-example-dumping-sam>Practical Toy Example: dumping SAM</h3><p>Any beginner pentester would (should?) know that in user-mode, a local Administrator account has enough privilege to dump the <code>SAM</code> & <code>SYSTEM</code> hives from the command line using <code>reg.exe</code>: (* If you didn‚Äôt know, I‚Äôd suggest reading this<sup class=footnote-reference id=fr-4-1><a href=#fn-4>[3]</a></sup> ASAP)<pre class=language-bat data-lang=bat style=color:#c0c5ce;background-color:#2b303b><code class=language-bat data-lang=bat><span>PS C:\WINDOWS\system32> </span><span style=color:#b48ead>reg</span><span>.exe save HKLM\SAM C:\Temp\SAM.bkp
</span><span>The operation completed successfully.
</span></code></pre><p>Same goes for <code>SYSTEM</code>.<p>However, even as Administrator trying to access using <code>regedit.exe</code> the subkeys of <code>HLKM\SECURITY</code> and <code>SAM</code> will be denied as they require <code>NT AUTHORITY\SYSTEM</code> privilege which is only a half protection, as <code>psexec /s</code> would be enough to bypass it. So with that in mind, in theory, <code>RegistryExplorer.js</code> gives us everything we need to fetch those values.<p>And then real life strikes‚Ä¶<h4 id=issue-1>Issue #1</h4><p>As I was trying to get those values manually, the initial script failed (crashed) complaining there was an invalid access to user-mode memory:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>GetCellDataAddress(Hive=ffffab04d1191000, Index=32): type=0 table=0 block=0 offset=32
</span><span>    [0x0]            : Unable to read target memory at '0x280f6fa1850' in method 'readMemoryValues' [at registryexplorer (line 20 col 18)]
</span></code></pre><p>It seemed that the cells for accessing the SAM were at some points hitting user-mode area, in a process different than <code>System</code>, so the address access walking the wrong page table, and hence the exception from WinDbg. Which got immediately confirmed:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dt _hmap_entry ffffab04d1191000
</span><span>nt!_HMAP_ENTRY
</span><span>   +0x000 BlockOffset      : 0
</span><span>   +0x008 PermanentBinAddress : 0x00000280`f6fa1001 <<< yup here, in UM
</span><span>   +0x010 MemAlloc         : 0x1000
</span></code></pre><p>Then how does the kernel know where to fetch this information? Well it turned out that the hive handle can hold reference to a process in its <code>ViewMap.ProcessTuple</code> attribute, of type <code>_CMSI_PROCESS_TUPLE</code> which holds both a handle to the <code>_EPROCESS</code> and a pointer to the <code>_EPROCESS</code>. We can use that information to determine the backing process:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dt _hhive ffffab04d1191000 ViewMap.ProcessTuple
</span><span>nt!_HHIVE
</span><span>   +0x0d8 ViewMap              :
</span><span>      +0x018 ProcessTuple         : 0xfffff805`422657c0 _CMSI_PROCESS_TUPLE
</span><span>
</span><span>0: kd> dx ((_CMSI_PROCESS_TUPLE*)0xfffff805`422657c0)->ProcessReference
</span><span>((_CMSI_PROCESS_TUPLE*)0xfffff805`422657c0)->ProcessReference : 0xffff828d85dbd080 [Type: void *]
</span><span>
</span><span>0: kd> dx @$cursession.Processes.Where( x => &(x.KernelObject) == (_EPROCESS*)0xffff828d85dbd080)
</span><span>@$cursession.Processes.Where( x => &(x.KernelObject) == (_EPROCESS*)0xffff828d85dbd080)
</span><span>    [0x54]           : Registry [Switch To]
</span></code></pre><p>It points to the <code>Registry</code> process, which makes sense. To confirm, we can switch to the context of the process, and try to re-access the UM address <code>0x280f6fa1850</code>:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dx -s @$cursession.Processes.Where( x => x.Name == "Registry").First().SwitchTo()
</span><span>0: kd> db 0x280f6fa1850
</span><span>00000280`f6fa1850  a8 ff ff ff 6e 6b 20 00-4a 92 fb 8e 6b 38 d5 01  ....nk .J...k8..
</span><span>00000280`f6fa1860  03 00 00 00 c0 02 00 00-06 00 00 00 00 00 00 00  ................
</span><span>00000280`f6fa1870  a0 1f 00 00 ff ff ff ff-01 00 00 00 28 2c 00 00  ............(,..
</span><span>[...]
</span></code></pre><p>The signature <code>kn</code> (0x6b6e) at <code>0x280f6fa1850+sizeof(ULONG)</code> confirms we‚Äôre hitting the right spot.<h4 id=issue-2>Issue #2</h4><p>Now I could access some keys & values but not everything:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dx @$SamHive = @$cursession.Registry.Hives.Where( x => x.MountPoint.EndsWith("SAM")).First()
</span><span>
</span><span>0: kd> dx @$SamHive.RootNode.Subkeys[0].Subkeys[0].Subkeys.Where(x => x.KeyName == "Account").First().Subkeys
</span><span>@$SamHive.RootNode.Subkeys[0].Subkeys[0].Subkeys.Where(x => x.KeyName == "Account").First().Subkeys                 : [object Generator]
</span><span>    [0x0]            : Aliases
</span><span>    [0x1]            : Groups
</span><span>    [0x2]            : Users
</span></code></pre><p>The 2nd issue faced was that when trying to access some keys in UM for the <code>HKLM\SAM</code> hive, WinDbg would inconsistently return some access violation error. This reason was somewhat easier to figure out the cause, less easy for a programmatic remediation.<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dx @$cursession.Registry.Hives.Where( x => x.MountPoint.EndsWith("SAM")).First().RootNode.Subkeys[0].Subkeys[0].Subkeys.Where(x => x.KeyName == "Account").First().Subkeys[2].Subkeys
</span><span>@$cursession.Registry.Hives.Where( x => x.MountPoint.EndsWith("SAM")).First().RootNode.Subkeys[0].Subkeys[0].Subkeys.Where(x => x.KeyName == "Account").First().Subkeys[2].Subkeys                 : [object Generator]
</span><span>GetCellDataAddress(Hive=ffffab04d1191000, Index=8096) = 280f6fa2fa0
</span><span>    [0x0]            : Unable to read target memory at '0x280f6fa2fa4' in method 'readMemoryValues' [at registryexplorer (line 20 col 18)]
</span></code></pre><p>The cause behind it was not the calculation method of the Cell address but due to the fact that the page was paged out. The clue for me was the fact the missing is usually surrounded by other mapped pages.<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> db 280f6fa2fa0
</span><span>00000280`f6fa2fa0  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????
</span><span>00000280`f6fa2fb0  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????
</span><span>00000280`f6fa2fc0  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????
</span><span>00000280`f6fa2fd0  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????
</span><span>00000280`f6fa2fe0  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????
</span><span>00000280`f6fa2ff0  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????
</span><span>00000280`f6fa3000  fe a3 d4 01 ff ff ff ff-ff ff ff 7f 57 8a 70 38  ............W.p8
</span><span>00000280`f6fa3010  c8 b0 d6 01 e9 03 00 00-01 02 00 00 14 02 00 00  ................
</span></code></pre><p>I didn‚Äôt find a way to solve this programmatically (i.e. force WinDbg to page-in), although just a reboot is enough to make sure the desired pages are still in memory. Then we can finally access the keys and values:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dx @$UserEncryptedPasswords = @$cursession.Registry.Hives.Where( x => x.MountPoint.EndsWith("SAM")).First().RootNode.Subkeys[0].Subkeys[0].Subkeys.Where(x => x.KeyName == "Account").First().Subkeys[2].Subkeys
</span><span>@$cursession.Registry.Hives.Where( x => x.MountPoint.EndsWith("SAM")).First().RootNode.Subkeys[0].Subkeys[0].Subkeys.Where(x => x.KeyName == "Account").First().Subkeys[2].Subkeys                 : [object Generator]
</span><span>    [0x0]            : 000001F4
</span><span>    [0x1]            : 000001F5
</span><span>    [0x2]            : 000001F7
</span><span>    [0x3]            : 000001F8
</span><span>    [0x4]            : 000003E9
</span><span>    [0x5]            : Names
</span></code></pre><p>So then to dump the keys for the <code>Administrator</code> (UID=500=0x1f4)<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dx @$UserEncryptedPasswords[0].Values
</span><span>@$UserEncryptedPasswords[0].Values                                  : [object Generator]
</span><span>    [0x0]            : F
</span><span>    [0x1]            : V
</span><span>    [0x2]            : SupplementalCredentials
</span><span>
</span><span>0: kd> dx @$UserEncryptedPasswords[0].Values[0]
</span><span>dx @$UserEncryptedPasswords[0].Values[0]                            : F
</span><span>    KeyHive          [Type: _HHIVE]
</span><span>    KeyValueObject   : 0x271ee85192c [Type: _CM_KEY_VALUE *]
</span><span>    KeyName          : F
</span><span>    KeyDataType      : REG_BINARY
</span><span>    KeyDataSize      : 0x50
</span><span>    Type             : CM_KEY_VALUE_SIGNATURE (6b76)
</span><span>    KeyDataRaw       : 3,0,1,0,0,0,0,0,0,...
</span></code></pre><p>And done, we‚Äôve got the data! We can now totally navigate the Registry from a KD session!<h2 id=outro>Outro</h2><p>Understanding those bits of the <abbr title="Configuration Manager">CM</abbr> took more work than I imagined, but as it was nicely engineered, it was fun to go through. The <abbr title="Configuration Manager">CM</abbr> is way more complex than that, but this is the basics: we didn‚Äôt cover more advanced stuff like the use of the <code>.LOG</code> file, the memory management of the <abbr title="Configuration Manager">CM</abbr> and other funkiness, but I hope this article was interesting and useful to you and thanks for making it this far.<p>Peace out ‚úå<h2 id=references>References</h2><ul><li><a class="fab fa-github" rel="noopener nofollow noreferrer" href=https://github.com/comaeio/SwishDbgExt target=_blank> <code>comaeio/SwishDbgExt</code> </a><li><a class="fab fa-github" rel="noopener nofollow noreferrer" href=https://github.com/reactos/reactos target=_blank> <code>reactos/reactos</code> </a><li><a rel="noopener nofollow noreferrer" href=https://www.microsoftpressstore.com/store/windows-internals-part-1-9780735648739 target=_blank>Windows Internals 6th - Part 1</a>, Chapter 4: Management Mechanism - The Registry<li><a rel="noopener nofollow noreferrer" href=http://moyix.blogspot.com/2008/02/enumerating-registry-hives.html target=_blank>Enumerating Registry Hives - moyix</a></ul><hr><ol class=footnotes-list><li id=fn-0><p><a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/windbg_js_scripts/blob/main/scripts/RegistryExplorer.js target=_blank>RegistryExplorer.js</a> <a href=#fr-0-1>‚Ü©</a> <a href=#fr-0-2>‚Ü©2</a></p><li id=fn-1><p><a rel="noopener nofollow noreferrer" href=https://web.archive.org/web/20220720121211/https://ivanlef0u.fr/repo/madchat/vxdevl/papers/winsys/wk_internals/registry.pdf target=_blank>Windows Kernel Internals NT Registry Implementation</a> <a href=#fr-1-1>‚Ü©</a> <a href=#fr-1-2>‚Ü©2</a> <a href=#fr-1-3>‚Ü©3</a></p><li id=fn-4><p><a rel="noopener nofollow noreferrer" href=https://web.archive.org/web/20140127003901/https://www.securusglobal.com/community/2013/12/20/dumping-windows-credentials/ target=_blank>Dumping Windows Credentials</a> by <a class="fab fa-twitter" href=https://twitter.com/lanjelot target=_blank> <code>@lanjelot</code> </a> <a href=#fr-4-1>‚Ü©</a></p></ol><aside class=post-tags><p>Categories: <a href=https://blahcat.github.io/categories/research/>#research</a><p>Tags: <a href=https://blahcat.github.io/tags/windows/>#windows</a> <a href=https://blahcat.github.io/tags/kernel/>#kernel</a> <a href=https://blahcat.github.io/tags/registry/>#registry</a> <a href=https://blahcat.github.io/tags/windbg/>#windbg</a></aside><aside class=post-discussion>Join the Discussion on <a href="https://github.com/blahcat/blahcat.github.io/discussions?discussions_q=Browsing the registry in kernel-mode" target=_blank> <i class="fab fa-github fa-lg"></i>¬†GitHub </a></aside><aside class=post-nav><div class=container><div class=row><div class=col><b>Next:</b><br><a class=post-nav-prev href=https://blahcat.github.io/2022-07-14-setup-hyperv-kdcom/> <section class=post-nav-teaser><b class=post-nav-title>Setup KDCOM for 2 Hyper-V VMs</b><p class=post-nav-excerpt>How to use Hyper-V to debug using KdCOM from 2 VMs, one debugging the other‚Ä¶</section> </a></div><div class=col><b>Previous:</b><br><a class=post-nav-next href=https://blahcat.github.io/2020-12-29-cheap-sandboxing-with-appcontainers/> <section class=post-nav-teaser><b class=post-nav-title>Cheap sandboxing with AppContainers</b><p class=post-nav-excerpt>Background This is a short blog post that I decided to finish recently afte‚Ä¶</section> </a></div></div></div></aside></div></div><hr><footer><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><ul class="list-inline text-center"><li class=list-inline-item><a href=https://blahcat.github.io/atom.xml> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fas fa-rss fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://twitter.com/ctf_blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-twitter fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://github.com/blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-github fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://www.youtube.com/channel/UCDrgY65mRZWVoMiB5-VMqfg> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-youtube fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://discord.gg/hSbqxxBgRX> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-discord fa-stack-1x fa-inverse"></i> </span> </a></ul><p class="copyright text-muted">Made with ‚ù§ with Zola</div></div></div></footer><script src=https://blahcat.github.io/js/jquery.min.js></script><script src=https://blahcat.github.io/js/bootstrap.bundle.min.js></script><script src=https://blahcat.github.io/js/clean-blog.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js></script><div class=mermaidTooltip style=opacity:0></div>