<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content=BlahCats name=author><meta content="Tales of a binary encoded life..." name=description><meta prefix="og: http://ogp.me/ns#" content=BlahCats property=og:site_name><meta prefix="og: http://ogp.me/ns#" content=blog property=og:type><meta content="Small dumps in the big pool" prefix="og: http://ogp.me/ns#" property=og:title><meta content="Small dumps in the big pool - by hugsy" prefix="og: http://ogp.me/ns#" property=og:description><meta prefix="og: http://ogp.me/ns#" content=en_US property=og:locale><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/2019-03-17-small-dumps-in-the-big-pool property=og:url><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/img/f4300721f56d68c92db76aa03c3bbd54.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=@ctf_blahcat name=twitter:site><meta content=BlahCats name=twitter:title><meta content="Small dumps in the big pool - by hugsy" name=twitter:description><meta content=https://blahcat.github.io/2019-03-17-small-dumps-in-the-big-pool name=twitter:url><meta content=https://blahcat.github.io/img/f4300721f56d68c92db76aa03c3bbd54.png name=twitter:image:src><script type=application/ld+json>
    {
      "@context" : "http://schema.org",
      "@type" : "Website",
      "name": " BlahCats",
      "url" : "https://blahcat.github.io/2019-03-17-small-dumps-in-the-big-pool",
      
      "image": https://blahcat.github.io/img/f4300721f56d68c92db76aa03c3bbd54.png",
      
      
      "description": Small dumps in the big pool - by hugsy",
      
    }
    </script><title>
  Small dumps in the big pool
</title><link href=https://blahcat.github.io/img/favicon.ico rel=icon type=image/x-icon><link href=https://blahcat.github.io/css/bootstrap.min.css rel=stylesheet><link href=" https://blahcat.github.io/css/all.min.css" rel=" stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Montserrat:400,300" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lato" -- <!-- custom for rel=stylesheet styles template this><link href=https://blahcat.github.io/css/clean-blog.css rel=stylesheet><link href=https://blahcat.github.io/css/overrides.css rel=stylesheet><link integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css referrerpolicy=no-referrer rel=stylesheet><body><nav class="navbar navbar-expand-lg navbar-light fixed-top" id=mainNav><div class=container><a class=navbar-brand href=https://blahcat.github.io>BlahCats Blog</a><button aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right" aria-controls=navbarResponsive aria-expanded=false data-target=#navbarResponsive data-toggle=collapse type=button>Menu <i class="fas fa-bars"></i></button><div class="collapse navbar-collapse" id=navbarResponsive><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://blahcat.github.io>Home</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/series>Series</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/notes>Notes</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/about>About</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/qemu>Qemu VMs</a></ul></div></div></nav><header class=masthead style=background-image:url(https://blahcat.github.io/img/f4300721f56d68c92db76aa03c3bbd54.png)><div class=overlay></div><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><div class=post-heading><h1>Small dumps in the big pool</h1><span class=meta> <b> • <a href=/author/hugsy>hugsy</a> • </b> 17 March 2019 <br> <br> <i>Reading time: 8 min</i> </span></div></div></div></div></header><article><article class=post><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><p>Or, on how to use the (Windows 10) new field <code>_ETHREAD.ThreadName</code> to stabilize kernel RW primitives<h2 id=setthreaddescription-as-a-way-to-allocate-controlled-kernel-pools>SetThreadDescription() as a way to allocate controlled kernel pools</h2><p>Keeping on with experimenting with Windows 10 I noticed a field part of the <code>nt!_ETHREAD</code> structure, called <code>ThreadName</code>. For a minute, the field name misled me to think threads were now <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows/desktop/sync/object-names target=_blank>Named Objects</a> on Windows. What it is instead, is a convenient and native way to name a thread, any thread by attaching a <code>UNICODE_STRING</code> structure to it. Thanks to <a class="fab fa-twitter" href=https://twitter.com/PetrBenes target=_blank> <code>@PetrBenes</code> </a> ’s invaluable <a rel="noopener nofollow noreferrer" href=https://ntdiff.github.io/ target=_blank><code>ntdiff</code></a> it became clear that this field was introduced with Windows 10, more specifically 1607.</p><a href=/img/small-pool/ntdiff.png target=_blank> <img alt=ntdiff src=/img/small-pool/ntdiff.png title=ntdiff width=100%> </a><p><a href="https://ntdiff.github.io/#versionLeft=Win8.1_U1%2Fx64%2FSystem32&filenameLeft=ntoskrnl.exe&typeLeft=Standalone%2F_ETHREAD&versionRight=Win10_1607_RS1%2Fx64%2FSystem32&filenameRight=ntoskrnl.exe&typeRight=Standalone%2F_ETHREAD" rel="noopener nofollow noreferrer" target=_blank>Source</a><p>So how to use it? Is it even reachable? The answer was as immediate as <a href="https://google.com/search?q=windows+10+set+thread+name" rel="noopener nofollow noreferrer" target=_blank>Googling “windows set thread name”</a> which leads to an <a href="https://docs.microsoft.com/en-us/visualstudio/debugger/how-to-set-a-thread-name-in-native-code?view=vs-2017" rel="noopener nofollow noreferrer" target=_blank>MSDN article</a>. This article mentions the <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-setthreaddescription target=_blank><code>SetThreadDescription()</code></a> in <code>processthreadsapi.h</code>. Disassembling <code>kernelbase.dll</code> shows that this function is merely a wrapper around the syscall <code>NtSetInformationThread()</code> with a <code>ThreadInformationClass</code> set to 0x26 (<code>ThreadNameInformation</code>).</p><a href=/img/small-pool/ida-setthreaddescription.png target=_blank> <img alt=ida-setthreaddescription src=/img/small-pool/ida-setthreaddescription.png title=ida-setthreaddescription width=100%> </a><p>Once in <code>ntoskrnl</code> (IDA), the syscall performs various checks (is the <code>_ETHREAD.ThreadName</code> already allocated, is the input size and buffer correct etc.), and then call <code>ExAllocatePoolWithTag()</code> with a tag of <code>ThNm</code> and as <code>NonPagedPoolNx</code>, and the size provided by the <code>UNICODE_STRING</code> structure, plus <code>sizeof(UNICODE_STRING)</code>. Finally, the user buffer will be <code>memmove</code>-ed into this new pool.</p><a href=/img/small-pool/ntsetinformationthread-1.png target=_blank> <img alt=ntsetinformationthread-1 src=/img/small-pool/ntsetinformationthread-1.png title=ntsetinformationthread-1 width=100%> </a><p>Since the unicode buffer and its size are fully user controlled, this means that the syscall <code>NtSetInformationThread(0x26)</code> provides a way to allocate an arbitrary sized pool in the kernel, for each thread we create and/or can open a handle to via <code>OpenThread()</code>.<div class=alert-info markdown=span><b class=markdown-alert-title> <svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" aria-hidden=true height=16 version=1.1 width=16><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg> Note </b><p><p>The code was tested on Windows 10 RS5 x64. To work on 32b one might need to adjust the offsets. Also Windows must be at least 1607.</div><p>The following code is enough to populate the <code>_ETHREAD.ThreadName</code> of a designed thread:</p><script src=https://gist.github.com/hugsy/8df0843e8556f557308cd014fec0fda3.js></script><p>The acute observer may notice that only <code>THREAD_SET_LIMITED_INFORMATION</code> class information is used. Therefore setting thread name with <code>ThreadNameInformation</code> is an operation that is not considered privileged and should work very reliably, just like <code>THREAD_QUERY_LIMITED_INFORMATION</code> to retrieve the thread name.</p><a href=/img/small-pool/setthreadname-1.png target=_blank> <img alt=image_alt src=/img/small-pool/setthreadname-1.png title=image_alt width=100%> </a><p>From WinDbg, the <code>!poolfind</code> command can be used to filter by tag name, in this case <code>ThNm</code> (0x6d4e6854), or query <code>!pool</code> with the address from the field <code>_ETHREAD!ThreadName</code>. This confirms that we fully control the content and size of pools. To be in the large pool, the chunk must be of at least 0x1000 bytes, making the minimum actual pool data size of 0x1000-0x10 bytes (for the header). And for the maxiumum allocatable size, during this experiment it was shown possible to allocate thread name up to 0xfff0 bytes (65520):<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>C:\Users\IEUser\Desktop>pslist -nobanner -d notepad
</span><span>Thread detail for MSEDGEWIN10:
</span><span>
</span><span>notepad 6828:
</span><span> Tid Pri    Cswtch            State     User Time   Kernel Time   Elapsed Time
</span><span>5488  10     28743     Wait:UserReq  0:00:00.093   0:00:00.609   85:44:03.789
</span><span>
</span><span>C:\Users\IEUser\Desktop>AllocateLargePool.exe 5488 65520
</span><span>tid=5488
</span><span>data stored at FFFFDD07B6F8C010
</span></code></pre><a href=/img/small-pool/setthreadname-2.png target=_blank> <img alt=image_alt src=/img/small-pool/setthreadname-2.png title=image_alt width=100%> </a><p>Which makes sense, since larger size would overflow the <code>Length</code> field of the <code>UNICODE_STRING</code> (i.e. <code>sizeof(WORD)</code>), which is checked during the <code>NtSetInformationThread(ThreadNameInformation)</code> syscall.<p>We have a reliable way to write from userland a large pool chunk and predict accurately its location in the kernel. Additionally the allocation operation is done per-thread, meaning that for more space it is possible to create more threads (<code>CreateThread()</code> locally or <code>OpenProcess()</code> + <code>CreateRemoteThread()</code> remotely).<p>Ok cool, but so what?<h2 id=leverage-as-exploit-primitive>Leverage as exploit primitive</h2><p>Although there’s no vulnerability there, one could use this technique to dump some data in the kernel in a vulnerability exploitation scenario such as an arbitrary write. One possible use case would be to store the addresses of a ROP sequence to disable SMEP. However, to achieve this the attacker must know the address where this pool in the kernel. Luckily we found the answer in the kernel “Large Pool” allocator. <a rel="noopener nofollow noreferrer" href=https://www.crowdstrike.com/blog/sheep-year-kernel-heap-fengshui-spraying-big-kids-pool/ target=_blank>Former analysis on the big pool allocator</a> have shown some interesting properties, but what makes it perfect is the <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows/desktop/api/winternl/nf-winternl-ntquerysysteminformation target=_blank><code>NtQuerySystemInformation()</code></a> syscall with the undocumented <a rel="noopener nofollow noreferrer" href=https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/bigpool_entry.htm target=_blank><code>SystemBigPoolInformation</code></a>(0x42) as class information, which provides <strong>exactly</strong> what we were looking for: the enumeration of all large pools with their kernel addresses, their size, and their tag.<p>This is enough to dump such information:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>#define </span><span>SystemBigPoolInformation </span><span style=color:#d08770>0x42
</span><span>
</span><span>[...]
</span><span>DWORD dwBufSize = </span><span style=color:#d08770>1024</span><span>*</span><span style=color:#d08770>1024</span><span>;
</span><span>DWORD dwOutSize;
</span><span>LPVOID pBuffer = </span><span style=color:#bf616a>LocalAlloc</span><span>(LPTR, dwBufSize);
</span><span>HRESULT hRes = </span><span style=color:#bf616a>NtQuerySystemInformation</span><span>(
</span><span>  SystemBigPoolInformation,
</span><span>  pBuffer,
</span><span>  dwBufSize,
</span><span>  &dwOutSize
</span><span>);
</span></code></pre><p>If large enough the buffer <code>pBuffer</code> will be populated by the kernel by <code>N</code> entries of <code>SYSTEM_BIGPOOL_ENTRY</code> structured as follow:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0x00 NumberOfEntries
</span><span>
</span><span>Entry0
</span><span>{
</span><span>  0x08 ULONG_PTR Entry0.Address
</span><span>  0x10 DWORD Entry0.PoolSize
</span><span>  0x18 DWORD Entry0.PoolTag
</span><span>}
</span><span>
</span><span>Entry1
</span><span>{
</span><span>  0x20 Entry1.Address
</span><span>[...]
</span><span>}
</span></code></pre><p>Which becomes trivial to parse to get the thread kernel address, simply by looking up for the entry that would match the condition <code>strncmp( info->PoolTag, "ThNm", 4)==0</code>. In the case of multi-threaded process with many ThreadName entries, it is possible to refine the search by using the size as a secondary search index:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>typedef struct
</span><span>{
</span><span>  DWORD64 Address;
</span><span>  DWORD64 PoolSize;
</span><span>  </span><span style=color:#b48ead>char</span><span> PoolTag[</span><span style=color:#d08770>4</span><span>];
</span><span>  </span><span style=color:#b48ead>char</span><span> Padding[</span><span style=color:#d08770>4</span><span>];
</span><span>}
</span><span>BIG_POOL_INFO, *PBIG_POOL_INFO;
</span><span>
</span><span>ULONG_PTR </span><span style=color:#8fa1b3>LookForThreadNamePoolAddress</span><span>(PVOID </span><span style=color:#bf616a>pSystemBigPoolInfoBuffer</span><span>, DWORD64 </span><span style=color:#bf616a>dwExpectedSize</span><span>)
</span><span>{
</span><span>  ULONG_PTR StartAddress = (ULONG_PTR)pSystemBigPoolInfoBuffer;
</span><span>  ULONG_PTR EndAddress = StartAddress + </span><span style=color:#d08770>8 </span><span>+ *( (PDWORD)StartAddress ) * sizeof(BIG_POOL_INFO);
</span><span>  ULONG_PTR ptr = StartAddress + </span><span style=color:#d08770>8</span><span>;
</span><span>  </span><span style=color:#b48ead>while </span><span>(ptr < EndAddress)
</span><span>  {
</span><span>    PBIG_POOL_INFO info = (PBIG_POOL_INFO) ptr;
</span><span>    </span><span style=color:#65737e>//printf("Name:%s Size:%llx Address:%llx\n", info->PoolTag, info->PoolSize, info->Address);
</span><span>
</span><span>    </span><span style=color:#b48ead>if</span><span>( </span><span style=color:#96b5b4>strncmp</span><span>( info->PoolTag, "</span><span style=color:#a3be8c>ThNm</span><span>", </span><span style=color:#d08770>4</span><span>)==</span><span style=color:#d08770>0 </span><span>&& dwExpectedSize==info->PoolSize )
</span><span>    {
</span><span>      </span><span style=color:#b48ead>return </span><span>(((ULONG_PTR)info->Address) & </span><span style=color:#d08770>0xfffffffffffffff0</span><span>) + sizeof(UNICODE_STRING);
</span><span>    }
</span><span>    ptr += sizeof(BIG_POOL_INFO);
</span><span>  }
</span><span>  </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>}
</span></code></pre><p>That’s pretty much it. <a rel="noopener nofollow noreferrer" href=https://gist.github.com/hugsy/d89c6ee771a4decfdf4f088998d60d19 target=_blank>Put it all together</a> and you get:<pre class=language-bat data-lang=bat style=color:#c0c5ce;background-color:#2b303b><code class=language-bat data-lang=bat><span>z:\> AllocateLargePool.exe </span><span style=color:#d08770>26948 4096
</span><span>[*] Target TID=</span><span style=color:#d08770>26948
</span><span>[+] Data from buffer 000001BCD71A0000 (</span><span style=color:#d08770>16</span><span> bytes) written </span><span style=color:#b48ead>at</span><span> FFFFD8001E966010
</span></code></pre><p>Some more advanced feng-shui can be achieved using <code>NtSetInformationThread(ThreadNameInformation)</code> which will be covered in a later post. Although convenient and really stealth, this technique is not bullet-proof since the syscall (if successful) is logged and may be exposed with ETW (see <code>nt!EtwTraceThreadSetName</code>).<p>What about local DoS? Well yes, it is a pretty simple to destabilize the system by resource exhaustion by creating a loop of <code>CreateThread()</code> + <code>AllocateBigPool($newThread)</code>: since it is possible to make each thread of a process allocate a chunk of 0x10000 bytes, simple math will show that creating a somewhat acceptable number of threads, say 0x1000 will bring the total allocation to 0x10000000 bytes (268MB). Not only can the number of threads per process be increased, but the same process can be launched many times. As mentioned earlier, the <code>_ETHREAD!ThreadName</code> field is allocated as <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows/desktop/memory/memory-pools target=_blank><code>NonPagedPoolNx</code></a> so all those chunks will never be paged out or freed until the thread (or process) is finished/terminated. Although this DoS is pretty dummy and useless, the only annoying part is that it can be triggered by even low integrity/privilege processes. Running <a rel="noopener nofollow noreferrer" href=https://gist.github.com/hugsy/a94392e6aeaf87335d06d06a0c05ff96 target=_blank>it</a> leads to an interesting scenario of memory pressure where the CPUs are not used but the system is unusable since pool allocation request will fail.<p>As a side note, on my test VM (Windows 10 RS5 with 2 vCpus and 2GB of RAM), I could force a process to spawn ~0xb900 threads before the system became unusable.</p><a href=/img/small-pool/dos-1.png target=_blank> <img alt=image_alt src=/img/small-pool/dos-1.png title=image_alt width=100%> </a><h2 id=final-words>Final words</h2><p>This post has shown that the apparently innocent new field <code>_ETHREAD.ThreadName</code> that appeared in Windows 1607 can be subverted to do a lot more than intended. But that’s definitely not all, some more esoteric (<em>cough</em> malware) could use this for stealth data persistence, or even covert channel (writing a tiny chat application based on the code above was fairly simple, and is left as an exercise to the reader). The thread name pool stays reachable in memory either until the thread is terminated, or another call to <code>NtSetInformationThread(ThreadNameInformation)</code> is done to this thread. This is convenient because some threads should unlikely die during the time of a session making such nice syscall a good place for hiding <em>stuff</em>.<p>That’s it for this little daily experiment. Until next time, cheers ☕️<h3 id=some-links-for-further-reading>Some links for further reading</h3><ul><li><a rel="noopener nofollow noreferrer" href=https://web.archive.org/web/20150419185055/https://media.blackhat.com/bh-dc-11/Mandt/BlackHat_DC_2011_Mandt_kernelpool-wp.pdf target=_blank>BlackHat DC 2011 - Mandt - Kernel Pool exploitation</a><li><a rel="noopener nofollow noreferrer" href=https://j00ru.vexillium.org/2018/07/exploiting-a-windows-10-pagedpool-off-by-one/ target=_blank>Exploiting a Windows 10 PagedPool off-by-one</a><li><a rel="noopener nofollow noreferrer" href=https://www.crowdstrike.com/blog/sheep-year-kernel-heap-fengshui-spraying-big-kids-pool/ target=_blank>Sheep Year Kernel Heap Fengshui: Spraying in the Big Kids’ Pool</a></ul><aside class=post-tags><p>Categories: <a href=https://blahcat.github.io/categories/research/>#research</a><p>Tags: <a href=https://blahcat.github.io/tags/windows/>#windows</a> <a href=https://blahcat.github.io/tags/kernel/>#kernel</a> <a href=https://blahcat.github.io/tags/pool/>#pool</a> <a href=https://blahcat.github.io/tags/rw-primitive/>#rw-primitive</a></aside><aside class=post-discussion>Join the Discussion on <a href="https://github.com/blahcat/blahcat.github.io/discussions?discussions_q=Small dumps in the big pool" target=_blank> <i class="fab fa-github fa-lg"></i> GitHub </a></aside><aside class=post-nav><div class=container><div class=row><div class=col><b>Next:</b><br><a class=post-nav-prev href=https://blahcat.github.io/2020-03-09-unexpected-logic-bug-win32k/> <section class=post-nav-teaser><b class=post-nav-title>An unexpected logic bug on Win32k</b><p class=post-nav-excerpt>The short version The short version is that there’s a small logic bug in u…</section> </a></div><div class=col><b>Previous:</b><br><a class=post-nav-next href=https://blahcat.github.io/2019-01-30-playing-with-windows-root-directory-object/> <section class=post-nav-teaser><b class=post-nav-title>Scripting with Windows Root Directory Object</b><p class=post-nav-excerpt>Still on my way to learning of Windows kernel, I spend considerable amount …</section> </a></div></div></div></aside></div></div><hr><footer><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><ul class="list-inline text-center"><li class=list-inline-item><a href=https://blahcat.github.io/atom.xml> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fas fa-rss fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://twitter.com/ctf_blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-twitter fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://github.com/blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-github fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://www.youtube.com/channel/UCDrgY65mRZWVoMiB5-VMqfg> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-youtube fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://discord.gg/hSbqxxBgRX> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-discord fa-stack-1x fa-inverse"></i> </span> </a></ul><p class="copyright text-muted">Made with ❤ with Zola</div></div></div></footer><script src=https://blahcat.github.io/js/jquery.min.js></script><script src=https://blahcat.github.io/js/bootstrap.bundle.min.js></script><script src=https://blahcat.github.io/js/clean-blog.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js></script><div class=mermaidTooltip style=opacity:0></div>