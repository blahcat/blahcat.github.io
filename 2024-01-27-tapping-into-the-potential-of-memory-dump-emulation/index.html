<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content=BlahCats name=author><meta content="Tales of a binary encoded life..." name=description><meta prefix="og: http://ogp.me/ns#" content=BlahCats property=og:site_name><meta prefix="og: http://ogp.me/ns#" content=blog property=og:type><meta content="Tapping into the potential of Memory Dump Emulation" prefix="og: http://ogp.me/ns#" property=og:title><meta content="Tapping into the potential of Memory Dump Emulation - by hugsy" prefix="og: http://ogp.me/ns#" property=og:description><meta prefix="og: http://ogp.me/ns#" content=en_US property=og:locale><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/2024-01-27-tapping-into-the-potential-of-memory-dump-emulation property=og:url><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/img/d9e336f7-602d-4efb-8234-0630e0d54f72.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=@ctf_blahcat name=twitter:site><meta content=BlahCats name=twitter:title><meta content="Tapping into the potential of Memory Dump Emulation - by hugsy" name=twitter:description><meta content=https://blahcat.github.io/2024-01-27-tapping-into-the-potential-of-memory-dump-emulation name=twitter:url><meta content=https://blahcat.github.io/img/d9e336f7-602d-4efb-8234-0630e0d54f72.png name=twitter:image:src><script type=application/ld+json>
    {
      "@context" : "http://schema.org",
      "@type" : "Website",
      "name": " BlahCats",
      "url" : "https://blahcat.github.io/2024-01-27-tapping-into-the-potential-of-memory-dump-emulation",
      
      "image": https://blahcat.github.io/img/d9e336f7-602d-4efb-8234-0630e0d54f72.png",
      
      
      "description": Tapping into the potential of Memory Dump Emulation - by hugsy",
      
    }
    </script><title>
  Tapping into the potential of Memory Dump Emulation
</title><link href=https://blahcat.github.io/img/favicon.ico rel=icon type=image/x-icon><link href=https://blahcat.github.io/css/bootstrap.min.css rel=stylesheet><link href=" https://blahcat.github.io/css/all.min.css" rel=" stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Montserrat:400,300" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lato" -- <!-- custom for rel=stylesheet styles template this><link href=https://blahcat.github.io/css/clean-blog.css rel=stylesheet><link href=https://blahcat.github.io/css/overrides.css rel=stylesheet><link integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css referrerpolicy=no-referrer rel=stylesheet><body><nav class="navbar navbar-expand-lg navbar-light fixed-top" id=mainNav><div class=container><a class=navbar-brand href=https://blahcat.github.io>BlahCats Blog</a><button aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right" aria-controls=navbarResponsive aria-expanded=false data-target=#navbarResponsive data-toggle=collapse type=button>Menu <i class="fas fa-bars"></i></button><div class="collapse navbar-collapse" id=navbarResponsive><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://blahcat.github.io>Home</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/series>Series</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/notes>Notes</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/about>About</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/qemu>Qemu VMs</a></ul></div></div></nav><header class=masthead style=background-image:url(https://blahcat.github.io/img/d9e336f7-602d-4efb-8234-0630e0d54f72.png)><div class=overlay></div><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><div class=post-heading><h1>Tapping into the potential of Memory Dump Emulation</h1><span class=meta> <b> • <a href=/author/hugsy>hugsy</a> • </b> 27 January 2024 <br> <br> <i>Reading time: 16 min</i> </span></div></div></div></div></header><article><article class=post><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><p>This post summarizes some of the work I’ve been doing for the past few months during my (few) off times. Nothing new, mostly just a structured reminder for my later self.<h2 id=introduction>Introduction</h2><p><a rel="noopener nofollow noreferrer" href=https://github.com/0vercl0k/wtf target=_blank><code>What-The-Fuzz</code></a> is one of my favorite tools, and beyond the tool itself I really enjoy the story behind the creation of the tool itself and all of the surrounding libraries <a rel="noopener nofollow noreferrer" href=https://github.com/0vercl0k target=_blank>0vercl0k</a> had to build, including <code>kdmp-parser</code>, <code>symbolizer</code>, leveraged <a rel="noopener nofollow noreferrer" href=https://github.com/yrp604 target=_blank>yrp</a>’s underestimated bochs-based emulation library <code>bochscpu</code>. 0vercl0k explained all of this better than I possible could, so if you haven’t read it yet, please stop reading this post now and read the blog post dedicated to WTF: <a rel="noopener nofollow noreferrer" href=https://doar-e.github.io/blog/2021/07/15/building-a-new-snapshot-fuzzer-fuzzing-ida/ target=_blank>Building a new snapshot fuzzer & fuzzing IDA</a>.<p>I used to use memory dump mostly as a final way to access the crashing condition and execution context of a program before its crash. Dumps are very much used for debugging, fuzzing crash analysis, and sometimes for DFIR (like with the famous - RIP? - <a rel="noopener nofollow noreferrer" href=https://github.com/volatilityfoundation/volatility target=_blank>Volatility</a> does). But to my knowledge, WTF was the first tool to use them for snapshot-based fuzzing (* if not, please shoot me a remark in the <a href="https://github.com/blahcat/blahcat.github.io/discussions?discussions_q=is%3Aopen+Tapping+into+the+potential+of+Memory+Dump+Emulation" rel="noopener nofollow noreferrer" target=_blank>Discussion</a>).<p>Following the well-known Feynman principle that <a rel="noopener nofollow noreferrer" href=https://simple.wikiquote.org/wiki/Richard_Feynman#cite_note-2 target=_blank>“what you cannot create, you do not understand”</a>, I wanted to see where digging into this topic will lead me. And boy wasn’t I disappointed… But first and before all, I wanted whatever my work to be Python because:<ul><li>it is the de-facto language for quick prototyping, comes with an awesome REPL and has a great ecosystem via PyPI<li>has a great capability to interact with lower level machine code<li>I know and like the language</ul><p>So immediately, I was stopped: originally <code>bochscpu</code> was written in Rust, <code>kdmp-parser</code> and <code>udmp-parser</code> in C++ and only <code>kdmp-parser</code> had an embryo of Python bindings (many API/structures missing, no PyPI). Perfect, so I set myself to completely dive into those libs by<ul><li>creating Python bindings for <code>udmp-parser</code> and <code>bochscpu</code><li>improving the Python bindings <code>kdmp-parser</code> <a rel="noopener nofollow noreferrer" href=https://github.com/0vercl0k/kdmp-parser/tree/3bec915e6f5304c187765be7ce3cfde713d7c29b target=_blank>originally had</a>, developed by <a class="fab fa-github" rel="noopener nofollow noreferrer" href=https://github.com/masthoon target=_blank> <code>masthoon</code> </a></ul><p>At the time of this article, anyone can <code>pip install</code> any of those packages and start playing directly within the Python interpreter 3.8+ on either Windows, Linux and MacOS (since 0.1.7+) So just in order to reproduce any of the stuff mentioned below, all one would need do is:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>pip</span><span> install udmp-parser kdmp-parser bochscpu-python
</span></code></pre><p>to be fully set to follow along with the experiments below. Having the pre-requisites we can start digging (because yes, all that initial work was only to get start the intended research) by:<ul><li>using <code>udmp-parser</code> to parse user-mode process dumps<li>or using <code>kdmp-parser</code>, to parse kernel memory dumps<li>and use those information to reconstitute a workable environment (memory layout, cpu context, etc.) for <code>bochscpu</code> to run whatever code we choose to.</ul><p>The best parts (IMO) about all of this was that this whole setup works no matter the process and allow us to get an absolute control over the execution.<p>We will explore each case individually, but first let’s examine a bit more the libraries at hand.<h2 id=quick-lib-peek>Quick lib peek</h2><p>This part is important as none of what follows would have been possible without those libraries, it is only fair to promote them first.<h3 id=bochs-1-bochscpu-2><code>Bochs[1]</code>/<code>BochsCPU[2]</code></h3><p>It is well-known that the <a rel="noopener nofollow noreferrer" href=https://github.com/bochs-emu/Bochs target=_blank>Bochs emulator</a> has incredibly powerful instrumentation capabilities and is regarded as being very faithful to the x86 ABI implementation itself (including the most recent extensions). <a rel="noopener nofollow noreferrer" href=https://github.com/yrp604/BochsCPU target=_blank><code>BochsCPU</code></a> by <a rel="noopener nofollow noreferrer" href=https://twitter.com/yrp604 target=_blank>yrp</a>, on the other hand, is a Rust library that wraps the Bochs CPU code and exposes via Rust API (and C++ via FFI) all the instrumentation points (context switches, interrupts, exceptions, etc) that Bochs does. This makes it a useful tool for tasks such as developing <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/bochscpu-python/blob/main/examples/real_mode_print_hello_world.py target=_blank>code any X86 mode</a>, dealing with very old, mission-critical software, and assisting in reversing/vulnerability research tasks.<p>And that’s an amazing environment since Bochs is extremely faithful to what the x86 cpu actually executes, it will be merciless should you fail to prepare the CPU state adequately (missing flags when setting long mode, forgot to reset a trap flag, etc.). Even though that could seem tedious, especially if compared to <code>unicorn/qemu</code> for instance, that abstracts everything beforehand to the dev. But I believe such behavior by forcing to read carefully the Intel manuals to have the expected behavior, it only makes you know X86 CPU better.<h3 id=udmp-parser-3-kdmp-parser-4><code>udmp-parser[3]</code>/<code>kdmp-parser[4]</code></h3><p><code>udmp-parser</code> and <code>kdmp-parser</code> are both cross-platform C++ parser library written by <a rel="noopener nofollow noreferrer" href=https://twitter.com/0vercl0k target=_blank>0vercl0k</a> for Windows memory dumps, respectively for user-mode (using <code>.dump /m</code> in WinDbg) and kernel-mode (<code>.dump /f|/ka</code> in WinDbg) dumps. And cherry on top, both come with Python3 bindings, allowing for quick prototyping.<h2 id=windows-kernel-mode-emulation>Windows Kernel-mode emulation</h2><p>Armed with those libraries, running the emulator from a Windows kernel dump is now “relatively” simple (as opposed to user-mode, we’ll detail why in the next part) because the dump is nothing more but a snapshot of the OS state at a given time.<h3 id=first-always-take-a-solid-dump>First, always take a solid dump</h3><p>First from a KdNet session, you can easily create a dump at an interesting point. When looking for interesting attack surface, I like to use my own <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/CFB target=_blank>IRP monitor tool</a> #ShamelessSelfPromo; but for our example really anything would do, like the following:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> bp /w "@$curprocess.Name == \"explorer.exe\"" nt!NtDeviceIoControlFile
</span><span>[...]
</span><span>Breakpoint 0 hit
</span><span>nt!NtDeviceIoControlFile:
</span><span>fffff807`4f7a4670 4883ec68        sub     rsp,68h
</span></code></pre><p>One way to get the dump would be using <code>.dump</code> command as such<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> .dump /ka c:\temp\ActiveKDump.dmp
</span></code></pre><p>But a better way would be to use the <a rel="noopener nofollow noreferrer" href=https://github.com/yrp604/bdump target=_blank>yrp’s <code>bdump.js</code></a> script<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> .scriptload "C:\bdump\bdump.js"
</span><span>[...]
</span><span>
</span><span>kd> !bdump_active_kernel "C:\\Temp\\ActiveKDump.dmp"
</span><span>[...]
</span><span>[bdump] saving mem, get a coffee or have a smoke, this will probably take around 10-15 minutes...
</span><span>[...]
</span><span>[bdump] Dump successfully written
</span><span>[bdump] done!
</span></code></pre><h3 id=build-the-bochscpu-session>Build the BochsCPU session</h3><p>Parsing the dump with <code>kdmp_parser.KernelDumpParser</code> is as simple as it gets so let’s leave it to that. For BochsCPU to run it’s critical to have a PF handler callback, which can be done as a simple on-demand basis: full memory dumps can be several gigabytes in size, so it seems unreasonable to map it all on host, especially since when we probably are going to need a fraction of that. This ended up being relatively elegant and simple:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>dmp = kdmp_parser.</span><span style=color:#bf616a>KernelDumpParser</span><span>(pathlib.</span><span style=color:#bf616a>Path</span><span>("</span><span style=color:#a3be8c>/path/to/dumpfile.dmp</span><span>"))
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>missing_page_cb</span><span>(</span><span style=color:#bf616a>pa</span><span>: int):
</span><span>  gpa = bochscpu.memory.</span><span style=color:#bf616a>align_address_to_page</span><span>(pa)
</span><span>  </span><span style=color:#b48ead>if </span><span>gpa in dmp.pages:          </span><span style=color:#65737e># do we already have the page in the dump?
</span><span>    </span><span style=color:#65737e># then create & copy the page content, resume execution
</span><span>    hva = bochscpu.memory.</span><span style=color:#bf616a>allocate_host_page</span><span>()
</span><span>    page = dmp.</span><span style=color:#bf616a>read_physical_page</span><span>(gpa)
</span><span>    bochscpu.memory.</span><span style=color:#bf616a>page_insert</span><span>(gpa, hva)
</span><span>    bochscpu.memory.</span><span style=color:#bf616a>phy_write</span><span>(gpa, page)
</span><span>
</span><span>sess = bochscpu.</span><span style=color:#bf616a>Session</span><span>()
</span><span>sess.missing_page_handler = missing_page_cb
</span></code></pre><p>This gives us a first chance to address missing pages, whereas the PageFault exception triggered by the CPU (i.e <code>PageFault</code> -> <code>BX_PF_EXCEPTION</code> (14) ) will give us a second chance to analyze the page fault, as the <code>error code</code> will be populated, we can check the reason of the fault using the <a rel="noopener nofollow noreferrer" href=https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3a-part-1-manual.pdf target=_blank>Intel 3A - 4.7 section</a> of the Intel manuals.<p>Next, a <code>bochscpu.State</code> must be given to the CPU indicating the context from which to start including the (extended) CR, GPR, flag registers and segment registers. Note that several helpers can be found in <code>bochscpu.cpu</code> to slightly speed up that process.<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>regs = json.</span><span style=color:#bf616a>loads</span><span>(pathlib.</span><span style=color:#bf616a>Path</span><span>("</span><span style=color:#a3be8c>/path/to/regs.json</span><span>").</span><span style=color:#bf616a>read_text</span><span>())
</span><span>state = bochscpu.</span><span style=color:#bf616a>State</span><span>()
</span><span>bochscpu.cpu.</span><span style=color:#bf616a>set_long_mode</span><span>(state)
</span><span>[</span><span style=color:#d08770>...</span><span>]
</span><span>state.cr3 = </span><span style=color:#bf616a>int</span><span>(regs["</span><span style=color:#a3be8c>cr3</span><span>"], </span><span style=color:#d08770>16</span><span>)
</span><span>state.cr0 = </span><span style=color:#bf616a>int</span><span>(regs["</span><span style=color:#a3be8c>cr0</span><span>"], </span><span style=color:#d08770>16</span><span>)
</span><span>state.cr4 = </span><span style=color:#bf616a>int</span><span>(regs["</span><span style=color:#a3be8c>cr4</span><span>"], </span><span style=color:#d08770>16</span><span>)
</span><span>[</span><span style=color:#d08770>...</span><span>]
</span><span>state.rax = </span><span style=color:#bf616a>int</span><span>(regs["</span><span style=color:#a3be8c>rax</span><span>"], </span><span style=color:#d08770>16</span><span>)
</span><span>state.rbx = </span><span style=color:#bf616a>int</span><span>(regs["</span><span style=color:#a3be8c>rbx</span><span>"], </span><span style=color:#d08770>16</span><span>)
</span><span>state.rcx = </span><span style=color:#bf616a>int</span><span>(regs["</span><span style=color:#a3be8c>rcx</span><span>"], </span><span style=color:#d08770>16</span><span>)
</span><span>state.rdx = </span><span style=color:#bf616a>int</span><span>(regs["</span><span style=color:#a3be8c>rdx</span><span>"], </span><span style=color:#d08770>16</span><span>)
</span><span>[</span><span style=color:#d08770>... </span><span>snip </span><span style=color:#b48ead>for </span><span>brievety]
</span><span>sess.cpu.state = state
</span></code></pre><p>Last (but technically optionally), define the Bochs callbacks on the plethora of hookable events:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>def </span><span style=color:#8fa1b3>before_execution_cb</span><span>(</span><span style=color:#bf616a>sess</span><span>: bochscpu.Session, </span><span style=color:#bf616a>cpu_id</span><span>: int, </span><span style=color:#bf616a>_</span><span>: int):
</span><span>    state = sess.cpu.state
</span><span>    logging.</span><span style=color:#bf616a>info</span><span>(</span><span style=color:#b48ead>f</span><span>"</span><span style=color:#a3be8c>Executing RIP=</span><span>{state.rip</span><span style=color:#d08770>:#016x</span><span>}</span><span style=color:#a3be8c> on </span><span>{cpu_id</span><span style=color:#b48ead>=</span><span>}")
</span><span>
</span><span>hook = bochscpu.</span><span style=color:#bf616a>Hook</span><span>()
</span><span>hook.before_execution = before_execution_cb
</span><span>hooks = [hook,]
</span></code></pre><p>And finally kick things off with a simple call<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>sess.</span><span style=color:#bf616a>run</span><span>(hooks)
</span><span>sess.</span><span style=color:#bf616a>stop</span><span>()
</span></code></pre><pre class=language-bat data-lang=bat style=color:#c0c5ce;background-color:#2b303b><code class=language-bat data-lang=bat><span>$ python kdump_runner.py
</span><span>Executing RIP=</span><span style=color:#d08770>0xfffff80720a9d4c0</span><span> on cpu_id=</span><span style=color:#d08770>0
</span><span>Executing RIP=</span><span style=color:#d08770>0xfffff80720a9d4c4</span><span> on cpu_id=</span><span style=color:#d08770>0
</span><span>Executing RIP=</span><span style=color:#d08770>0xfffff80720a9d4cb</span><span> on cpu_id=</span><span style=color:#d08770>0
</span><span>Executing RIP=</span><span style=color:#d08770>0xfffff80720a9d4d0</span><span> on cpu_id=</span><span style=color:#d08770>0
</span><span>Executing RIP=</span><span style=color:#d08770>0xfffff80720a9d4d4</span><span> on cpu_id=</span><span style=color:#d08770>0
</span><span>Executing RIP=</span><span style=color:#d08770>0xfffff80720a9d4dc</span><span> on cpu_id=</span><span style=color:#d08770>0
</span><span>Executing RIP=</span><span style=color:#d08770>0xfffff80720a9d4e1</span><span> on cpu_id=</span><span style=color:#d08770>0
</span><span>Executing RIP=</span><span style=color:#d08770>0xfffff80720a9d4e8</span><span> on cpu_id=</span><span style=color:#d08770>0
</span><span>Executing RIP=</span><span style=color:#d08770>0xfffff80720a9d4ec</span><span> on cpu_id=</span><span style=color:#d08770>0
</span><span>[...]
</span></code></pre><p>For a complete and more detailed example, the reader can refer to the example in the <code>bochscpu-python</code> repository: <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/bochscpu-python/blob/main/examples/long_mode_emulate_windows_kdump.py target=_blank>examples/long_mode_emulate_windows_kdump.py</a><h2 id=windows-user-mode-emulation>Windows User-mode emulation</h2><p>There are way more than one way of snapshotting a process on Windows (like WinDbg, Task Manager, <code>procdump</code>, <code>processhacker</code>, etc.) so I will skip and assume you have a snapshot ready.<p>Emulating usermode code on BochsCPU turned out to be slightly more tricky than kernel mode: the kernel dump includes an almost complete OS snapshot include all the kernel sections required by the MMU to function properly and all what was needed was to map those pages to Bochs whenever they were needed.<p>A user-mode dump on Windows does not include any of those information but only that related to the usermode process itself - which, despite being already a lot of information, is insufficient to simply re-use what was done for kernel mode emulation. And we must remember that BochsCPU is only, well, the CPU: meaning it can execute anything but it needs to have everything set it up, such as the processor mode (real, protected, long), the map pages, etc. But then, if the process runs in protected/long mode, memory accesses via the MMU must also be correctly laid off so ensure the VirtualAddress → PhysicalAddress translation works. We therefore, are required to build own page table for the process. Since this process is <a rel="noopener nofollow noreferrer" href=https://wiki.osdev.org/Page_Tables target=_blank>documented</a> <a rel="noopener nofollow noreferrer" href=https://software.intel.com/en-us/articles/intel-sdm target=_blank>everywhere</a> <a rel="noopener nofollow noreferrer" href=https://www.memorymanagement.org/ target=_blank>on the Internet</a>, I will assume the reader to be familiar and skip this part by mentioning that <code>bochscpu-python</code> provides an easy way to expedite the process of setting things up:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>dmp = udmp_parser.</span><span style=color:#bf616a>UserDumpParser</span><span>()
</span><span style=color:#b48ead>assert </span><span>dmp.</span><span style=color:#bf616a>Parse</span><span>(dmp_path)
</span><span>pt = bochscpu.memory.</span><span style=color:#bf616a>PageMapLevel4Table</span><span>()
</span><span>pa = </span><span style=color:#bf616a>PA_START_ADDRESS
</span><span>
</span><span style=color:#65737e># Collect the memory regions from the Windows dump
</span><span style=color:#65737e># For each region, insert a new PT entry
</span><span style=color:#b48ead>for </span><span style=color:#bf616a>_</span><span>, region </span><span style=color:#b48ead>in </span><span>dmp.</span><span style=color:#bf616a>Memory</span><span>().</span><span style=color:#bf616a>items</span><span>():
</span><span>    </span><span style=color:#b48ead>if </span><span>region.State == </span><span style=color:#bf616a>MEM_FREE </span><span>or region.Protect == </span><span style=color:#bf616a>PAGE_NOACCESS</span><span>:
</span><span>        </span><span style=color:#b48ead>continue
</span><span>    start, end = region.BaseAddress, region.BaseAddress + region.RegionSize
</span><span>    </span><span style=color:#b48ead>for </span><span>va </span><span style=color:#b48ead>in </span><span style=color:#96b5b4>range</span><span>(start, end, </span><span style=color:#bf616a>PAGE_SIZE</span><span>):
</span><span>        flags = </span><span style=color:#bf616a>convert_region_protection</span><span>(region.Protect)
</span><span>        </span><span style=color:#b48ead>if </span><span>flags < </span><span style=color:#d08770>0</span><span>:
</span><span>            </span><span style=color:#b48ead>break
</span><span>        pt.</span><span style=color:#bf616a>insert</span><span>(va, pa, flags)
</span><span>        hva = bochscpu.memory.</span><span style=color:#bf616a>allocate_host_page</span><span>()
</span><span>        bochscpu.memory.</span><span style=color:#bf616a>page_insert</span><span>(pa, hva)
</span><span>        </span><span style=color:#96b5b4>print</span><span>(</span><span style=color:#b48ead>f</span><span>"</span><span style=color:#96b5b4>\b</span><span style=color:#a3be8c>Mapped </span><span>{va</span><span style=color:#b48ead>=</span><span style=color:#d08770>:#x</span><span>}</span><span style=color:#a3be8c> to </span><span>{pa</span><span style=color:#b48ead>=</span><span style=color:#d08770>:#x</span><span>}</span><span style=color:#a3be8c> with </span><span>{flags</span><span style=color:#b48ead>=</span><span>}</span><span style=color:#96b5b4>\r</span><span>", </span><span style=color:#bf616a>end</span><span>="")
</span><span>        pa += </span><span style=color:#bf616a>PAGE_SIZE
</span><span>
</span><span style=color:#65737e># Commit all the changes, resulting in a valid PT setup for the VM
</span><span style=color:#b48ead>for </span><span>hva, gpa </span><span style=color:#b48ead>in </span><span>pt.</span><span style=color:#bf616a>commit</span><span>(</span><span style=color:#bf616a>PML4_ADDRESS</span><span>):
</span><span>    bochscpu.memory.</span><span style=color:#bf616a>page_insert</span><span>(gpa, hva)
</span></code></pre><p>A couple of other things are required: the first one is that just like for what was done for kernel dumps, we must import all registers (GPR, flags). Another thing (but related) relies in the thread selection: when the VM execution will resume, the CPU cannot work without relying on the segment registers, which are provided from its state by the values set in the CS, DS, SS segment registers. Thankfully those values can be retrieved straight from the dump:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>threads = dmp.</span><span style=color:#bf616a>Threads</span><span>()
</span><span>tids = </span><span style=color:#bf616a>list</span><span>(threads.</span><span style=color:#bf616a>keys</span><span>())
</span><span>tid = tids[</span><span style=color:#d08770>0</span><span>] </span><span style=color:#65737e># whatever teh first thread is, but TID can be hardcoded too
</span><span style=color:#bf616a>switch_to_thread</span><span>(state, threads[tid])
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>switch_to_thread</span><span>(</span><span style=color:#bf616a>state</span><span>: bochscpu.State, </span><span style=color:#bf616a>thread</span><span>: udmp_parser.Thread):
</span><span>  </span><span style=color:#65737e># build CS
</span><span>  _cs = bochscpu.</span><span style=color:#bf616a>Segment</span><span>()
</span><span>  _cs.base = </span><span style=color:#d08770>0
</span><span>  _cs.limit = </span><span style=color:#d08770>0xFFFF_FFFF
</span><span>  _cs.selector = thread.Context.SegCs
</span><span>  _cs_attr = bochscpu.cpu.</span><span style=color:#bf616a>SegmentFlags</span><span>()
</span><span>  _cs_attr.A = </span><span style=color:#d08770>True
</span><span>  _cs_attr.R = </span><span style=color:#d08770>True
</span><span>  _cs_attr.E = </span><span style=color:#d08770>True
</span><span>  _cs_attr.S = </span><span style=color:#d08770>True
</span><span>  _cs_attr.P = </span><span style=color:#d08770>True
</span><span>  _cs_attr.L = </span><span style=color:#d08770>True
</span><span>  _cs.attr = </span><span style=color:#bf616a>int</span><span>(_cs_attr)
</span><span>  state.cs = _cs
</span><span>
</span><span>  </span><span style=color:#65737e># do the same for the others (obvisouly adjusting values/flags)
</span></code></pre><p>Similarly not the CPU but Windows also requires the FS (for protected and long modes) and the GS registers (in long mode).<p>Ok, now we have built everything need for the emulation to run successfully in a Windows environment. Let’s focus on what could we want to execute next…<h3 id=pgtfo>PGTFO</h3><p>TL;DR You can predict through emulation the values of Windows PRNG (see <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/bochscpu-python/blob/main/examples/long_mode_emulate_windows_udump.py target=_blank>examples/long_mode_emulate_windows_udump.py</a>)<p>Coincidentally as part of some research I was doing for work on ransomware, I examined the possibility of retrieving session keys used by ransomware, by snapshotting culprit ransomware processes, and generating a using memory dumps using canary files (the full article is available <a rel="noopener nofollow noreferrer" href=https://www.elastic.co/security-labs/ransomware-in-the-honeypot-how-we-capture-keys target=_blank>here</a> if interested). As thoroughly detailed in the article, investigating <code>WANNACRY</code> revealed that it uses Windows PRNG to create the AES128 keys for each file. Which triggered the idea behind that post, which was that by using canary files to detect ransomware encryption early one, and generating a dump of the process at that point, can we retrieve all the subsequent symmetric keys (and essentially making ourselves a free decryptor).<p>Since snapshotting the process gives us the current state of the PRNG for that process, we can now use emulation to discover the following values. A basic PoC for it would be as follow:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>#include </span><span><</span><span style=color:#a3be8c>windows.h</span><span>>
</span><span style=color:#b48ead>#include </span><span><</span><span style=color:#a3be8c>wincrypt.h</span><span>>
</span><span style=color:#b48ead>#include </span><span><</span><span style=color:#a3be8c>stdio.h</span><span>>
</span><span style=color:#b48ead>#pragma</span><span> comment(lib, "advapi32.lib")
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>()
</span><span>{
</span><span>    HCRYPTPROV hCryptProv;
</span><span>    </span><span style=color:#bf616a>CryptAcquireContext</span><span>(&hCryptProv, </span><span style=color:#d08770>NULL</span><span>, </span><span style=color:#d08770>NULL</span><span>, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT);
</span><span>    </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#a3be8c>PID=</span><span style=color:#d08770>%lu</span><span style=color:#a3be8c>, hProv=</span><span style=color:#d08770>%p</span><span style=color:#96b5b4>\n</span><span style=color:#a3be8c>Dump and press enter</span><span style=color:#96b5b4>\n</span><span>", </span><span style=color:#bf616a>GetCurrentProcessId</span><span>(), (</span><span style=color:#b48ead>void </span><span>*)hCryptProv);
</span><span>    </span><span style=color:#96b5b4>getchar</span><span>(); </span><span style=color:#65737e>// We break here and snapshot the process
</span><span>
</span><span>    </span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>int</span><span> i = </span><span style=color:#d08770>0</span><span>; i < </span><span style=color:#d08770>10</span><span>; i++)
</span><span>    {
</span><span>        BYTE randomBytes[</span><span style=color:#d08770>16</span><span>] = {</span><span style=color:#d08770>0</span><span>};
</span><span>        </span><span style=color:#bf616a>CryptGenRandom</span><span>(hCryptProv, sizeof(randomBytes), randomBytes)
</span><span>        </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#a3be8c>Random bytes: </span><span>");
</span><span>        </span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>int</span><span> i = </span><span style=color:#d08770>0</span><span>; i < sizeof(randomBytes); i++)
</span><span>          </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#d08770>%02X </span><span>", randomBytes[i]);
</span><span>        </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#96b5b4>\n</span><span>");
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#bf616a>CryptReleaseContext</span><span>(hCryptProv, </span><span style=color:#d08770>0</span><span>);
</span><span>    </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>}
</span></code></pre><a href=/img/d9e336f7-602d-4efb-8234-0630e0d54f72.png target=_blank> <img alt="Get the dump" title="Get the dump" src=/img/d9e336f7-602d-4efb-8234-0630e0d54f72.png width=100%> </a><p>Continuing our emulator from above, we can now invoke directly any function (here we’re interested in <code>cryptbase!SystemFunction036</code>) in the dump:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>logging.</span><span style=color:#bf616a>debug</span><span>(</span><span style=color:#b48ead>f</span><span>"</span><span style=color:#a3be8c>Resolving 'cryptbase!SystemFunction036'</span><span>")
</span><span>fn_start = </span><span style=color:#bf616a>resolve_function</span><span>(fn_sym)
</span><span>fn_end = fn_start + </span><span style=color:#d08770>0x1C </span><span style=color:#65737e># hardcode the end address of the function for now
</span><span>
</span><span>state.rcx = temp_buffer_va
</span><span>state.rdx = </span><span style=color:#d08770>16
</span><span>state.rip = fn_start
</span><span>
</span><span>hook = bochscpu.</span><span style=color:#bf616a>Hook</span><span>()
</span><span>hook.before_execution = </span><span style=color:#b48ead>lambda </span><span style=color:#bf616a>s</span><span>, </span><span style=color:#bf616a>_</span><span>: s.cpu.state.rip == fn_end and s.</span><span style=color:#bf616a>stop</span><span>()
</span><span>sess.</span><span style=color:#bf616a>run</span><span>([hook,])
</span></code></pre><p>And we can successfully dump all future values:</p><a href=/img/a0641b11-efdc-4d06-84af-51d404cf0ed5.png target=_blank> <img alt=emulate src=/img/a0641b11-efdc-4d06-84af-51d404cf0ed5.png title=emulate width=100%> </a><p>Same values, mission accomplished.<h2 id=hey-but-what-about-linux>Hey, but what about Linux?</h2><p>Well as the saying goes…</p><a href=https://media.giphy.com/media/xTiTnL7OS5ZWUUWMU0/giphy.gif target=_blank> <img alt=same-but-different src=https://media.giphy.com/media/xTiTnL7OS5ZWUUWMU0/giphy.gif title=same-but-different width=100%> </a><p>using <a rel="noopener nofollow noreferrer" href=https://lief-project.github.io/doc/latest/tutorials/12_elf_coredump.html target=_blank>lief</a> we can parse and populate the memory layout<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#65737e>/**
</span><span style=color:#65737e> * For demo purpose, compiled with `-static`
</span><span style=color:#65737e> */
</span><span style=color:#b48ead>#include </span><span><</span><span style=color:#a3be8c>stdlib.h</span><span>>
</span><span style=color:#b48ead>#include </span><span><</span><span style=color:#a3be8c>stdio.h</span><span>>
</span><span style=color:#b48ead>#include </span><span><</span><span style=color:#a3be8c>stdint.h</span><span>>
</span><span style=color:#b48ead>#include </span><span><</span><span style=color:#a3be8c>time.h</span><span>>
</span><span>
</span><span style=color:#b48ead>void </span><span style=color:#8fa1b3>generate_random_buffer</span><span>(uint8_t* </span><span style=color:#bf616a>buf</span><span>, size_t </span><span style=color:#bf616a>sz</span><span>)
</span><span>{
</span><span>  </span><span style=color:#b48ead>for</span><span>(</span><span style=color:#b48ead>int</span><span> i=</span><span style=color:#d08770>0</span><span>; i&LTsz; i++)
</span><span>    buf[i] = </span><span style=color:#96b5b4>rand</span><span>() & </span><span style=color:#d08770>0xff</span><span>;
</span><span>}
</span><span>
</span><span style=color:#b48ead>int </span><span style=color:#8fa1b3>main</span><span>()
</span><span>{
</span><span>  </span><span style=color:#96b5b4>srand</span><span>(</span><span style=color:#96b5b4>time</span><span>(</span><span style=color:#d08770>NULL</span><span>));
</span><span>  uint8_t buf[</span><span style=color:#d08770>0x10</span><span>] = {</span><span style=color:#d08770>0</span><span>};
</span><span>  </span><span style=color:#bf616a>generate_random_buffer</span><span>(buf, sizeof(buf));
</span><span>  </span><span style=color:#96b5b4>getchar</span><span>(); </span><span style=color:#65737e>// get a coredump
</span><span>  </span><span style=color:#b48ead>for</span><span>(</span><span style=color:#b48ead>int</span><span> i=</span><span style=color:#d08770>0</span><span>; i&LTsizeof(buf); i++)
</span><span>    </span><span style=color:#96b5b4>printf</span><span>("</span><span style=color:#d08770>%02x </span><span>", buf[i]);
</span><span>  </span><span style=color:#96b5b4>puts</span><span>("");
</span><span>  </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>}
</span></code></pre><p>Compile <a href=/img/a31f6e3a-5c8a-40a6-8c6d-29e6b023d07a.png target=_blank> <img alt="Alt text" title="Alt text" src=/img/a31f6e3a-5c8a-40a6-8c6d-29e6b023d07a.png width=100%> </a><p>And run <a href=/img/8594fc66-e5da-477d-850c-1ea320c42ccf.png target=_blank> <img alt="Alt text" title="Alt text" src=/img/8594fc66-e5da-477d-850c-1ea320c42ccf.png width=100%> </a><p>and unsurprisingly, same result<p>Similarly the source of this script too was added to the <code>examples/</code> folder of <code>bochscpu-python</code> available <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/bochscpu-python/blob/main/examples/long_mode_emulate_linux_udump.py target=_blank>here</a> so feel free to try it at home 🙂<h2 id=bochspwn-re-reloaded>BochsPwn (Re-)Reloaded?</h2><p><a rel="noopener nofollow noreferrer" href=https://github.com/googleprojectzero/bochspwn target=_blank>BochsPwn</a> (and <a rel="noopener nofollow noreferrer" href=https://github.com/googleprojectzero/bochspwn-reloaded target=_blank>BochsPwn-Reloaded</a>) is a project developed by <a rel="noopener nofollow noreferrer" href=https://twitter.com/j00ru target=_blank>j00ru</a> which leveraged Bochs instrumentation capability to detect (among other things) TOCTOU race conditions in the Windows kernel. The brilliance behind that tool can (partially) become relevant again for kernel memory dumps, by simply tracking executions and memory accesses. This can be achieved crudely by extending the kernel dump runner we had earlier, and adding a callback for linear memory accesses in <code>bochscpu</code> as such:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>@</span><span style=color:#bf616a>dataclass
</span><span style=color:#b48ead>class </span><span style=color:#ebcb8b>TrackedMemoryAccess</span><span style=color:#eff1f5>:
</span><span>    timestamp: int
</span><span>    pc: int
</span><span>    address: int
</span><span>    access: bochscpu.memory.AccessType
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>lin_access_cb</span><span>(
</span><span>    </span><span style=color:#bf616a>sess</span><span>: bochscpu.Session,
</span><span>    </span><span style=color:#bf616a>cpu_id</span><span>: int,
</span><span>    </span><span style=color:#bf616a>lin</span><span>: int,
</span><span>    </span><span style=color:#bf616a>phy</span><span>: int,
</span><span>    </span><span style=color:#bf616a>len</span><span>: int,
</span><span>    </span><span style=color:#bf616a>memtype</span><span>: int,
</span><span>    </span><span style=color:#bf616a>rw</span><span>: int,
</span><span>):
</span><span>    </span><span style=color:#b48ead>global </span><span>tracked_accesses
</span><span>
</span><span>    state = sess.cpu.state
</span><span>    </span><span style=color:#b48ead>if </span><span>lin >= </span><span style=color:#bf616a>MAX_USERMODE_ADDRESS</span><span>:
</span><span>        </span><span style=color:#65737e># Ignore accessed linear address as long as it stays in KM
</span><span>        </span><span style=color:#b48ead>return
</span><span>
</span><span>    </span><span style=color:#b48ead>if </span><span>rw:
</span><span>        </span><span style=color:#65737e># Ignore write access (for now)
</span><span>        </span><span style=color:#b48ead>return
</span><span>
</span><span>    </span><span style=color:#65737e># Track the current access
</span><span>    cur = </span><span style=color:#bf616a>TrackedMemoryAccess</span><span>(sess[</span><span style=color:#bf616a>AUX_INSN_COUNT</span><span>], sess[</span><span style=color:#bf616a>AUX_LAST_RIP</span><span>], lin, bochscpu.memory.</span><span style=color:#bf616a>AccessType</span><span>(memtype))
</span><span>    logging.</span><span style=color:#bf616a>debug</span><span>(</span><span style=color:#b48ead>f</span><span>"{cur.pc</span><span style=color:#b48ead>=</span><span style=color:#d08770>:#x</span><span>}</span><span style=color:#a3be8c>: </span><span>{cur.address</span><span style=color:#b48ead>=</span><span style=color:#d08770>:#x</span><span>}</span><span style=color:#a3be8c> -> </span><span>{phy</span><span style=color:#b48ead>=</span><span style=color:#d08770>:#x</span><span>} {</span><span style=color:#96b5b4>len</span><span style=color:#b48ead>=</span><span>} {cur.access</span><span style=color:#b48ead>=</span><span>}")
</span><span>
</span><span>    </span><span style=color:#65737e># Look for previous accesses
</span><span>    </span><span style=color:#b48ead>for </span><span>old </span><span style=color:#b48ead>in </span><span>tracked_accesses:
</span><span>      </span><span style=color:#65737e># Any access to the same VA means a match
</span><span>      </span><span style=color:#b48ead>if </span><span>old.address == cur.address and old.access == cur.access:
</span><span>          logging.</span><span style=color:#bf616a>error</span><span>(
</span><span>            </span><span style=color:#b48ead>f</span><span>"</span><span style=color:#a3be8c>Possible usermode </span><span>{cur.access}</span><span style=color:#a3be8c> double fetch on VA=</span><span>{cur.address</span><span style=color:#d08770>:#x</span><span>}</span><span style=color:#a3be8c>:</span><span style=color:#96b5b4>\n</span><span>"
</span><span>            </span><span style=color:#b48ead>f</span><span>"</span><span style=color:#a3be8c>1st access at </span><span>{old.pc</span><span style=color:#d08770>:#x</span><span>}</span><span style=color:#a3be8c> -> </span><span>{old.</span><span style=color:#bf616a>insn</span><span>(sess)}</span><span style=color:#96b5b4>\n</span><span>"
</span><span>            </span><span style=color:#b48ead>f</span><span>"</span><span style=color:#a3be8c>2nd access at </span><span>{cur.pc</span><span style=color:#d08770>:#x</span><span>}</span><span style=color:#a3be8c> -> </span><span>{cur.</span><span style=color:#bf616a>insn</span><span>(sess)}</span><span style=color:#96b5b4>\n</span><span>"
</span><span>            </span><span style=color:#b48ead>f</span><span>"</span><span style=color:#a3be8c>exec distance: </span><span>{cur.timestamp - old.timestamp}</span><span style=color:#a3be8c> insn(s)</span><span>"
</span><span>          )
</span><span>          </span><span style=color:#b48ead>raise </span><span>SuspiciousCrashException
</span><span>
</span><span>    tracked_accesses.</span><span style=color:#bf616a>append</span><span>(cur)
</span><span>
</span><span>[..snip..]
</span><span>hook.lin_access_cb = lin_access_cb
</span><span>
</span><span>sess.</span><span style=color:#bf616a>run</span><span>([hook,])
</span></code></pre><p>Testing with <a rel="noopener nofollow noreferrer" href=https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/ target=_blank>HEVD</a> <a rel="noopener nofollow noreferrer" href=https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/blob/master/Driver/HEVD/Windows/DoubleFetch.c target=_blank>Double-Fetch</a> example, immediately reveals it:<pre class=language-bat data-lang=bat style=color:#c0c5ce;background-color:#2b303b><code class=language-bat data-lang=bat><span>❯ python .\hevd_double_fetch.py X:\hevd_double_fetch_dump\</span><span style=color:#b48ead>mem</span><span>.dmp X:\hevd_double_fetch_dump\regs.json
</span><span>INFO:Parsed KernelDumpParser(X:\hevd_double_fetch_dump\</span><span style=color:#b48ead>mem</span><span>.dmp, CompleteMemoryDump)
</span><span>ERROR:Possible usermode bochscpu._bochscpu.memory.AccessType.Read double fetch on VA=</span><span style=color:#d08770>0x5f0008</span><span>:
</span><span>1st access </span><span style=color:#b48ead>at </span><span style=color:#d08770>0xfffff8071fde68d6</span><span> -> mov r9, [rdi+8h]
</span><span>2nd access </span><span style=color:#b48ead>at </span><span style=color:#d08770>0xfffff8071fde6905</span><span> -> mov r8, [rdi+8h]
</span><span>exec distance: </span><span style=color:#d08770>85</span><span> insn(s)
</span><span>ERROR:Exception  raised
</span><span>> z:\bochscpu-fun\hevd_double_fetch.py(</span><span style=color:#d08770>180</span><span>)lin_access_cb()
</span><span>-> raise SuspiciousCrashException
</span><span>
</span><span>(Pdb) bochscpu.utils.dump_registers(sess.cpu.state)
</span><span>rax=</span><span style=color:#d08770>0000000000000000</span><span> rbx=</span><span style=color:#d08770>0000000000000000</span><span> rdx=</span><span style=color:#d08770>0000000000000001
</span><span>rsi=</span><span style=color:#d08770>0000000000000003</span><span> rdi=00000000005f0000 rbp=ffff988c2cebae90
</span><span>rsp=fffffd8650f8e880 rip=fffff8071fde6909  r8=0000000000000008
</span><span> r9=000000000000004d r10=fffff8071fde5078 r11=fffffd8650f8e878
</span><span>r12=</span><span style=color:#d08770>0000000000000001</span><span> r13=ffff988c2d80ee00 r14=000000000000004d
</span><span>r15=0000000000000800
</span><span>efl=</span><span style=color:#d08770>00040206</span><span> [ id vip vif AC vm rf nt of df </span><span style=color:#b48ead>IF</span><span> tf sf zf af PF cf  ]
</span><span>cs=</span><span style=color:#d08770>0010</span><span>  ss=0018  ds=002b  es=002b  fs=</span><span style=color:#d08770>0053</span><span>  gs=002b
</span><span>
</span><span>(Pdb) </span><span style=color:#b48ead>print</span><span>(utils.hexdump(bochscpu.memory.virt_read(sess.cpu.state.cr3, sess.cpu.state.rdi, </span><span style=color:#d08770>0x10</span><span>)))
</span><span style=color:#d08770>0x0000000000000000</span><span>   AA AA AA AA AA AA AA AA </span><span style=color:#d08770>10 00 00 00 00 00 00 00</span><span>     ................
</span></code></pre><p>Which we can double-check with a disassembler (highlighted in magenta)</p><a href=/img/0bd46b07-e495-419d-ae11-8373868735fe.png target=_blank> <img alt="Alt text" title="Alt text" src=/img/0bd46b07-e495-419d-ae11-8373868735fe.png width=100%> </a><h2 id=final-remark>Final remark</h2><p>This article was made an attempt to structure all my notes over the last few months playing with memory dumps, and by no mean any comparison with WTF: WTF goes way further and does it better, with different emulation techniques and therefore should be used for fuzzing at scale. On the other hand having quick ways to re-create a fully working emulation context (whether user or kernel mode) from a process/memory dump with ~50 lines of Python is not without certain advantages.<p>Anyway, as always open for feedback on the discussion feed.<p>Until then see next time, Cheers 🍻<h2 id=references>References</h2><p>Here are the links to those giants referred in the title:<ol><li><a class="fab fa-github" rel="noopener nofollow noreferrer" href=https://github.com/bochs-emu/Bochs target=_blank> <code>bochs-emu/Bochs</code> </a><li><a class="fab fa-github" rel="noopener nofollow noreferrer" href=https://github.com/yrp604/bochscpu target=_blank> <code>yrp604/bochscpu</code> </a><li><a class="fab fa-github" rel="noopener nofollow noreferrer" href=https://github.com/0vercl0k/wtf target=_blank> <code>0vercl0k/wtf</code> </a><li><a class="fab fa-github" rel="noopener nofollow noreferrer" href=https://github.com/0vercl0k/kdmp-parser target=_blank> <code>0vercl0k/kdmp-parser</code> </a><li><a class="fab fa-github" rel="noopener nofollow noreferrer" href=https://github.com/0vercl0k/udmp-parser target=_blank> <code>0vercl0k/udmp-parser</code> </a><li><a class="fab fa-github" rel="noopener nofollow noreferrer" href=https://github.com/googleprojectzero/bochspwn target=_blank> <code>googleprojectzero/bochspwn</code> </a><li><a class="fab fa-github" rel="noopener nofollow noreferrer" href=https://github.com/googleprojectzero/bochspwn-reloaded target=_blank> <code>googleprojectzero/bochspwn-reloaded</code> </a></ol><aside class=post-tags><p>Categories: <a href=https://blahcat.github.io/categories/research/>#research</a><p>Tags: <a href=https://blahcat.github.io/tags/windows/>#windows</a> <a href=https://blahcat.github.io/tags/memory-dump/>#memory-dump</a> <a href=https://blahcat.github.io/tags/wtf/>#wtf</a> <a href=https://blahcat.github.io/tags/bochscpu/>#bochscpu</a> <a href=https://blahcat.github.io/tags/bochs/>#bochs</a> <a href=https://blahcat.github.io/tags/emulation/>#emulation</a></aside><aside class=post-discussion>Join the Discussion on <a href="https://github.com/blahcat/blahcat.github.io/discussions?discussions_q=Tapping into the potential of Memory Dump Emulation" target=_blank> <i class="fab fa-github fa-lg"></i> GitHub </a></aside><aside class=post-nav><div class=container><div class=row><div class=col></div><div class=col><b>Previous:</b><br><a class=post-nav-next href=https://blahcat.github.io/2023-04-04-section-objects-kernel-user-communication-mode/> <section class=post-nav-teaser><b class=post-nav-title>Section Objects as Kernel/User communication mode</b><p class=post-nav-excerpt>I’ve recently decided to read cover to cover some Windows Internals books, …</section> </a></div></div></div></aside></div></div><hr><footer><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><ul class="list-inline text-center"><li class=list-inline-item><a href=https://blahcat.github.io/atom.xml> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fas fa-rss fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://twitter.com/ctf_blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-twitter fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://github.com/blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-github fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://www.youtube.com/channel/UCDrgY65mRZWVoMiB5-VMqfg> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-youtube fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://discord.gg/hSbqxxBgRX> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-discord fa-stack-1x fa-inverse"></i> </span> </a></ul><p class="copyright text-muted">Made with ❤ with Zola</div></div></div></footer><script src=https://blahcat.github.io/js/jquery.min.js></script><script src=https://blahcat.github.io/js/bootstrap.bundle.min.js></script><script src=https://blahcat.github.io/js/clean-blog.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js></script><div class=mermaidTooltip style=opacity:0></div>