<!doctype html><html lang=en><head><meta charset=utf-8><meta content="width=device-width,initial-scale=1,shrink-to-fit=no" name=viewport><meta content=BlahCats name=author><meta content="Tales of a binary encoded life..." name=description><meta prefix="og: http://ogp.me/ns#" content=BlahCats property=og:site_name><meta prefix="og: http://ogp.me/ns#" content=blog property=og:type><meta content="Some toying with the Self-Reference PML4 Entry" prefix="og: http://ogp.me/ns#" property=og:title><meta content="Some toying with the Self-Reference PML4 Entry - by hugsy" prefix="og: http://ogp.me/ns#" property=og:description><meta prefix="og: http://ogp.me/ns#" content=en_US property=og:locale><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/2020-06-15-playing-with-self-reference-pml4-entry property=og:url><meta prefix="og: http://ogp.me/ns#" content=https://blahcat.github.io/img/f7803990-4baa-4a9a-a09b-0cde30694fa6.png property=og:image><meta content=summary_large_image name=twitter:card><meta content=@ctf_blahcat name=twitter:site><meta content=BlahCats name=twitter:title><meta content="Some toying with the Self-Reference PML4 Entry - by hugsy" name=twitter:description><meta content=https://blahcat.github.io/2020-06-15-playing-with-self-reference-pml4-entry name=twitter:url><meta content=https://blahcat.github.io/img/f7803990-4baa-4a9a-a09b-0cde30694fa6.png name=twitter:image:src><script type=application/ld+json>
    {
      "@context" : "http://schema.org",
      "@type" : "Website",
      "name": " BlahCats",
      "url" : "https://blahcat.github.io/2020-06-15-playing-with-self-reference-pml4-entry",
      
      "image": https://blahcat.github.io/img/f7803990-4baa-4a9a-a09b-0cde30694fa6.png",
      
      
      "description": Some toying with the Self-Reference PML4 Entry - by hugsy",
      
    }
    </script><title>
  Some toying with the Self-Reference PML4 Entry
</title><link href=https://blahcat.github.io/img/favicon.ico rel=icon type=image/x-icon><link href=https://blahcat.github.io/css/bootstrap.min.css rel=stylesheet><link href=" https://blahcat.github.io/css/all.min.css" rel=" stylesheet"><link href="https://fonts.googleapis.com/css?family=Roboto" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Montserrat:400,300" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Lato" -- <!-- custom for rel=stylesheet styles template this><link href=https://blahcat.github.io/css/clean-blog.css rel=stylesheet><link href=https://blahcat.github.io/css/overrides.css rel=stylesheet><link integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css referrerpolicy=no-referrer rel=stylesheet><body><nav class="navbar navbar-expand-lg navbar-light fixed-top" id=mainNav><div class=container><a class=navbar-brand href=https://blahcat.github.io>BlahCats Blog</a><button aria-label="Toggle navigation" class="navbar-toggler navbar-toggler-right" aria-controls=navbarResponsive aria-expanded=false data-target=#navbarResponsive data-toggle=collapse type=button>Menu <i class="fas fa-bars"></i></button><div class="collapse navbar-collapse" id=navbarResponsive><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=https://blahcat.github.io>Home</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/series>Series</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/notes>Notes</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/about>About</a><li class=nav-item><a class=nav-link href=https://blahcat.github.io/qemu>Qemu VMs</a></ul></div></div></nav><header class=masthead style=background-image:url(https://blahcat.github.io/img/f7803990-4baa-4a9a-a09b-0cde30694fa6.png)><div class=overlay></div><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><div class=post-heading><h1>Some toying with the Self-Reference PML4 Entry</h1><span class=meta> <b> ‚Ä¢ <a href=/author/hugsy>hugsy</a> ‚Ä¢ </b> 15 June 2020 <br> <br> <i>Reading time: 16 min</i> </span></div></div></div></div></header><article><article class=post><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><p>Sometimes you read about an awesome exploitation technique (<a href=https://blahcat.github.io/2020-06-15-playing-with-self-reference-pml4-entry/#links>#1</a>), so you want to go deeper. So this is my notes about how trying to totally understand the exploitation of CVE-2020-0796 (<a href=https://blahcat.github.io/2020-06-15-playing-with-self-reference-pml4-entry/#links>#2</a>), I ended up struggling finding good explanation about a critical structure of Windows paging mechanism: the ‚ÄúSelf-Reference PML4 Entry‚Äù. <em>Disclaimer</em>: If you came here for new stuff, so let me put your mind at peace: There‚Äôs nothing new here, I don‚Äôt claim to find anything what‚Äôs being found and said by people way smarter, and I have probably understood it wrong anyway so don‚Äôt judge/quote me. Also the post will only talk be about x64 and Windows here (and having a (L)KD open can help to follow along).<h2 id=mmu-101>MMU 101</h2><p>Although this post won‚Äôt be only about the <abbr title="Memory Management Unit">MDL</abbr> (there‚Äôs a book for that <a href=https://blahcat.github.io/2020-06-15-playing-with-self-reference-pml4-entry/#links>#3</a>), some background is required for understanding why there is a need for the so-called Self-Reference PML4 entry. The root question for that is a simple (but not trivial) one: how does the processor read/write a block of physical memory, <strong>only</strong> by knowing the virtual address, or in layman‚Äôs term, how to go from Virtual Address to Physical Address?<h3 id=segmentation>Segmentation</h3><p>On Intel and AMD processors, a virtual address is a combination of a <em>segment number</em> <strong>and</strong> <em>a linear address</em>, or <code>segment_number:linear_address</code> and even on 64b architecture segmentation is still necessary. So in long mode, a code virtual address is never just <code>0xLinearAddress</code> but always <code>cs:0xLinearAddress</code>, data is <code>ds:0xLinearAddress</code>, stack is <code>ss:0xLinearAddress</code>, and so on, where <code>cs</code>, <code>ds</code>, <code>ss</code> register holds a WORD value corresponding to an index (with the 2 least significant bit OR-ed, designating the <abbr title="Current Privilege Level">CPL</abbr>) . The segment number will be added to the value of the register <code>gdtr</code> and will get the segment descriptor:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> r cs, rip, gdtr
</span><span>cs=0010 rip=fffff80041e811e0, gdtr=fffff80044b5dfb0
</span><span>kd> dd @gdtr + @cs l2
</span><span>fffff800`44b5dfc0  00000000 00209b00
</span><span>kd> .formats 00209b00
</span><span>[...]
</span><span>Binary:  [..] 00000000 00100000 10011011 00000000
</span></code></pre><p>Which we can parse combined with the format given by the AMD manual:<p><a href=https://i.ibb.co/NNgJdgz/image.png target=_blank> <img alt=image_alt src=https://i.ibb.co/NNgJdgz/image.png title=image_alt width=100%> </a> (Src: AMD Programmer‚Äôs Manual Volume 2)<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0x00209b00   = 0000 0000 ‚Ä≠ 0010 0000 1001 1011 0000 0000‚Ä¨
</span><span>               [BaseL  ]  gdLa      P| 1 1CRA [BaseM  ]
</span><span>                                     |
</span><span>                                     ‚Ü≥ DPL=0
</span><span>
</span><span>0x00000000   = 0000 0000  0000 0000  0000 0000  0000 0000
</span><span>               [ BaseAddress 15:0 ]  [  Seg Limit 15:0  ]
</span></code></pre><p>The <abbr title="Current Privilege Level">CPL</abbr> being given by the 2 lowest bytes of CS, it is now easy to understand how the CPU performs privilege check: by simply comparing the <abbr title="Current Privilege Level">CPL</abbr> from CS register and <abbr title="Descriptor Privilege Level">DPL</abbr> from the segment descriptor, or if you prefer a visual diagram from the AMD manual:<p><a href=https://i.ibb.co/kDFzxB8/image.png target=_blank> <img alt=image_alt src=https://i.ibb.co/kDFzxB8/image.png title=image_alt width=100%> </a> (Src: AMD Programmer‚Äôs Manual Volume 2)<p>As we saw earlier, the <code>Address</code> and <code>Limit</code> parts of the descriptor are equal to 0 in Long-Mode (64-bit) - this may be the source of confusion I read in some blog posts (but no name shaming, it‚Äôs not the point üòã).<p>Also if you‚Äôre lazy (like me) and addicted to WinDbg (like me), the <code>dg</code> command will pretty-print all those info for you:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> dg @cs
</span><span>                                                    P Si Gr Pr Lo
</span><span>Sel        Base              Limit          Type    l ze an es ng Flags
</span><span>0010 00000000`00000000 00000000`00000000 Code RE Ac 0 Nb By P  Lo 0000029b
</span><span>
</span><span>kd> dg @ds
</span><span>                                                    P Si Gr Pr Lo
</span><span>Sel        Base              Limit          Type    l ze an es ng Flags
</span><span>002B 00000000`00000000 00000000`ffffffff Data RW Ac 3 Bg Pg P  Nl 00000cf3
</span></code></pre><p>There is plenty more to say about the segmentation mechanism on x86, but for our purpose (reminder: <em>how does the CPU goes from VA to PA?</em>), we‚Äôll stick to those basic highlights.<h3 id=paging>Paging</h3><p>Preparing this post, I came across <a rel="noopener nofollow noreferrer" href=https://connormcgarr.github.io/paging/ target=_blank>this blog post</a> that <a class="fab fa-twitter" href=https://twitter.com/33y0re target=_blank> <code>@33y0re</code> </a> wrote recently, and where he did a really good job summarizing how paging works on x86-64 long-mode, and how to explore it on Windows. Therefore I will send you reader to his article, and assume from then on you know of PML4, PDPT, PD, PT and what a canonical linear address is.<p>The best summary can be given by this diagram (again from AMD‚Äôs manual)<p><a href=https://i.ibb.co/k5TDWgw/image.png target=_blank> <img alt=image_alt src=https://i.ibb.co/k5TDWgw/image.png title=image_alt width=100%> </a> <em>Source: AMD Programmer‚Äôs Manual Volume 2</em><h2 id=what-why-the-hell-is-self-reference-pml4-entry>What & why the hell is ‚ÄúSelf-Reference PML4 entry‚Äù ?</h2><p>Back to the problem at hand, i.e. understand how does the CPU go from VA to PA, there is an intrinsic problem: the CPU only uses virtual address so how could the processor manipulates the permissions, flags, etc. of those PTEs which are physical? Simply by mapping the PTE tables in VAS, right? But that creates a recursive problem, because we still don‚Äôt know how to go from VA to PA. And that‚Äôs precisely where ‚ÄúSelf-Reference PML4 entry‚Äù comes in. But let‚Äôs go back a bit.<p>When a new process is created, a new PML4 is also allocated holding the physical root address for our process address space. From that physical root address and with all the offsets from the VA itself, the <abbr title="Memory Management Unit">MDL</abbr> can crawl down the physical page directories until getting the wanted data (see ‚ÄúPaging‚Äù above). This physical address is stored in the <a rel="noopener nofollow noreferrer" href=https://www.vergiliusproject.com/kernels/x64/Windows%2010%20%7C%202016/2004%2020H1%20(May%202020%20Update)/_KPROCESS target=_blank><code>nt!_KPROCESS</code></a> structure of the process, precisely in <code>_KPROCESS.DirectoryTableBase</code>.<p>To experiment this behavior, we can create a simple program that will only <code>int3</code> so that KD gets the hand while still in user-mode:<pre class=language-c data-lang=c style=color:#c0c5ce;background-color:#2b303b><code class=language-c data-lang=c><span style=color:#b48ead>void </span><span style=color:#8fa1b3>main</span><span>() {</span><span style=color:#b48ead>__asm__</span><span>("</span><span style=color:#a3be8c>int3;</span><span>"); }
</span></code></pre><p>Compile and execute, and as expected KD notifies the breakpoint:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>Break instruction exception - code 80000003 (first chance)
</span><span>int3+0x6d08:
</span><span>0033:00007ff7`83f26d08 cc              int     3
</span><span>kd> dx @$curprocess.KernelObject.Pcb.DirectoryTableBase
</span><span>@$curprocess.KernelObject.Pcb.DirectoryTableBase : 0x762ec002 [Type: unsigned __int64]
</span><span>kd> dx @$curprocess.KernelObject.Pcb.DirectoryTableBase == @cr3
</span><span>@$curprocess.KernelObject.Pcb.DirectoryTableBase == @cr3 : true
</span></code></pre><p>So when a process switch occurs, the kernel can move <code>nt!_EPROCESS.KernelObject.Pcb.DirectoryTableBase</code> into <code>cr3</code> (that <code>mov</code> operation forcing the TLB cache being flushed), given the newly running process the illusion of having a clean full virtual address space, and by the same way physically isolating processes.<p>But we slightly digressed, back to the topic: in order to map in the VAS our PML4 which is in physical address space, the kernel needs a way to always know at least one entry of the PML4: this is the <u>‚ÄúSelf-Reference Entry‚Äù</u>. Also seen to be called ‚Äúauto-entry‚Äù, the <em>Self-Reference Entry</em> (or ‚Äúself-ref entry‚Äù for short) is a special PML4 index (so then only 9-bit in size) that only the kernel knows (hence between 0x100-0x1ff), and whose content points the physical address of the PML4 itself. By doing so, Windows kernel gives itself an easy way to reach by a virtual address, any directory (PML4, PDPT, PDE, etc.).<p>On Windows 7, the self-ref entry index is a static value (0x1ed) whereas Windows 10 randomizes it on boot. So to understand why this Self-Reference Entry is helpful, let‚Äôs process a virtual address like the <abbr title="Memory Management Unit">MDL</abbr> would: the PML4 index corresponds to the 39:47 bits of a VA, so the value 0x1ed (or 0b111101101) would be as follow:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>Bi| 6   ...  4444 4444 3333  ...
</span><span>t#| 3   ...  7654 3210 9876  ...
</span><span>Va|          1111 0110 1xxx     <&LT-- 0x1ed
</span><span>lu|
</span></code></pre><p>So for all Windows from 7 to 10 TH2, the PML4 table of <strong>all processes</strong> was always mapped <strong>at the same range</strong> 0xFFFFF680`00000000 ‚Üí 0xFFFFF6FF`FFFFFFFF. The randomization was added by Windows 10 RS1.<p>So let‚Äôs translate a special VA 0xFFFFF6FB`7DBED000‚Ä¨ to a physical address (PA): by decomposing its indexes we get:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span> *   pml4e_offset     : 0x1ed
</span><span> *   pdpe_offset      : 0x1ed
</span><span> *   pde_offset       : 0x1ed
</span><span> *   pte_offset       : 0x1ed
</span><span> *   offset           : 0x000
</span></code></pre><div class=alert-info markdown=span><b class=markdown-alert-title> <svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" aria-hidden=true height=16 version=1.1 width=16><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg> Note </b><p><p>the output is from my <a rel="noopener nofollow noreferrer" href=https://github.com/hugsy/windbg_js_scripts/blob/master/scripts/PageExplorer.js target=_blank><code>PageExplorer.js</code></a> WinDbg script.</div><p>The PML4E of the current process can be reached at <code>CR3 + 0x1ed*@$ptrsize</code>: but the content is the base physical address of the PML4 itself again! So the PDPE will itself also translate to the PML4 and so on until we read the <code>PTE+offset</code> which again will return the base address of the PML4 (because <code>offset=0</code>)! So what we get is an easy way to read the content of not just the PML4 itself, but any page directory, and all simply by knowing that 9-bit value (and therefore, calculating the corresponding PXE)! So you can artificially create VA simply by their offset, for instance to read the PageTable instead?<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span> *   pml4e_offset     : 0x1ed
</span><span> *   pdpe_offset      : 0x000
</span><span> *   pde_offset       : 0x000
</span><span> *   pte_offset       : 0x000
</span><span> *   offset           : 0x000
</span></code></pre><p>And build the address as<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0xffff<&LT48 | $pml4e_offset<&LT39 | $pdpe_offset<&LT30 | $pde_offset<&LT21 | $pte_offset<&LT12 | $offset
</span><span> => 0xffff<&LT48 | 0x1ed<&LT39 | 0<&LT30 | 0<&LT21 | 0<&LT12 | 0
</span></code></pre><p>And you get the value: 0xFFFFF680`00000000.<p>That‚Äôs why older versions of Windows (which did not randomized the Self-Reference entry and had it hardcoded at 0x1ed) offered a great avenue for defeating KASLR even remotely because you knew for sure always where the PageTable was, and there was a way to browse all pages of a process without ever faulting. And even on modern recent Windows 10, it still means with an arbitrary write you can defeat KASLR and SMEP/SMAP together.<p>To summarize (or if you just jumped to the end of this section), what‚Äôs awesome about the <em>Self-Reference PML4 Entry</em> is that knowing only 9 bits (for example 0x1ed) we can <strong>easily dump physical memory</strong>!<h2 id=what-about-windows-10-rs1>What about Windows 10 RS1+?</h2><p>Up until Windows 10 TH2, the magic index for the Self-Reference PML4 entry was 0x1ed as mentioned above. But what about Windows 10 from 1607? Well Microsoft uped their game, as a <a rel="noopener nofollow noreferrer" href=https://www.blackhat.com/docs/us-16/materials/us-16-Weston-Windows-10-Mitigation-Improvements.pdf target=_blank>constant battle for improving Windows security</a> the index is randomized at boot-time, so 0x1ed is now one of the 512 possible values (i.e. 9-bit index) that the Self-Reference entry index can have. And side effect, it also broke some of their own tools, like the <code>!pte2va</code> WinDbg command.<p>On Windows 2004 x64, 0xFFFFF680`00000000 points to nothing (at least most of the times ü§ì)<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> db 0xFFFFF680`00000000 l20
</span><span>fffff680`00000000  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????
</span><span>fffff680`00000010  ?? ?? ?? ?? ?? ?? ?? ??-?? ?? ?? ?? ?? ?? ?? ??  ????????????????
</span></code></pre><p>But is it really 512 values for the entry? Well no, because the most significant bit must be set to 1 for the Sign-Extension to properly make it a kernel canonical address. So it is more 256 values (from 0x100 to 0x1ff). If we‚Äôre in KD, this index can be retrieved by a new global symbol <code>nt!MmPteBase</code>, and so the self-reference entry can be known as:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> dq nt!MmPteBase l1
</span><span>fffff804`29e29388  fffff880`00000000
</span><span>kd> ? (poi(nt!MmPteBase) >> 0n39) & 0x1ff
</span><span>Evaluate expression: 497 = 00000000`000001f1
</span></code></pre><p>In our current KD session on a Windows 2004 (on Hyper-V), the self-reference entry has the index of 0x1f1. So now we have the PML4 index, we can craft the virtual address to get its physical address:<ul><li>calculate the PTE VA</ul><pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> ? 0xffff<&LT0n48 | 0x1f1<&LT0n39 | 0x1f1<&LT0n30 | 0x1f1<&LT0n21 | 0x1f1<&LT0n12 | 000
</span><span>Evaluate expression: -7711643201536 = fffff8fc`7e3f1000
</span></code></pre><ul><li>get the entry info</ul><pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> !pte 0xfffff8fc7e3f1000
</span><span>@$pte(0xfffff8fc7e3f1000)                 : VA=0xfffff8fc7e3f1000, PA=0x4c7d1000, Offset=0x0
</span><span>    va               : -7711643201536
</span><span>    cr3              : 0x4c7d1000
</span><span>    pml4e_offset     : 0x1f1
</span><span>    pdpe_offset      : 0x1f1
</span><span>    pde_offset       : 0x1f1
</span><span>    pte_offset       : 0x1f1
</span><span>    offset           : 0x0
</span><span>    pml4e            : PDE(PA=4c7d1000, PFN=4c7d1, Flags=PRwK--AD-eX)
</span><span>    pdpe             : PDE(PA=4c7d1000, PFN=4c7d1, Flags=PRwK--AD-eX)
</span><span>    pde              : PDE(PA=4c7d1000, PFN=4c7d1, Flags=PRwK--AD-eX)
</span><span>    pte              : PTE(PA=4c7d1000, PFN=4c7d1, Flags=PRwK--AD-eX)
</span><span>    pa               : 0x4c7d1000
</span><span>    kernel_pxe       : 0xfffff8fc7e3f1f88
</span></code></pre><p>As we see, for each entry (PML4E, PDPTE, etc.) the base address found is always the same <strong>and</strong> matches the content of <code>CR3</code>. We can also easily prove this is the self-reference entry index: as stated above, the entry index (in our example 0x1f1) has to be the same for all processes, meaning that if we break into another process context, the kernel PXE will be the same. Let‚Äôs try with our <code>int3.exe</code> again:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>Break instruction exception - code 80000003 (first chance)
</span><span>0033:00007ff6`2ac36d08 cc              int     3
</span><span>kd> !pte 0xfffff8fc7e3f1000
</span><span>@$pte(0xfffff8fc7e3f1000)                 : VA=0xfffff8fc7e3f1000, PA=0x1b1f7000, Offset=0x0
</span><span>    va               : -7711643201536
</span><span>    cr3              : 0x1b1f7000
</span><span>    pml4e_offset     : 0x1f1
</span><span>    pdpe_offset      : 0x1f1
</span><span>    pde_offset       : 0x1f1
</span><span>    pte_offset       : 0x1f1
</span><span>    offset           : 0x0
</span><span>    pml4e            : PDE(PA=1b1f7000, PFN=1b1f7, Flags=PRwK--AD-eX)
</span><span>    pdpe             : PDE(PA=1b1f7000, PFN=1b1f7, Flags=PRwK--AD-eX)
</span><span>    pde              : PDE(PA=1b1f7000, PFN=1b1f7, Flags=PRwK--AD-eX)
</span><span>    pte              : PTE(PA=1b1f7000, PFN=1b1f7, Flags=PRwK--AD-eX)
</span><span>    pa               : 0x1b1f7000
</span><span>    kernel_pxe       : 0xfffff8fc7e3f1f88
</span></code></pre><p>And to confirm the VA points to the correct PA:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> db 0xfffff8fc7e3f1000
</span><span>fffff8fc`7e3f1000  67 28 16 62 00 00 00 8a-67 58 c8 11 00 00 00 8a  g(.b....gX......
</span><span>fffff8fc`7e3f1010  00 00 00 00 00 00 00 00-67 f8 40 77 00 00 00 8a  ........g.@w....
</span><span>
</span><span>kd> !db 0x1b1f7000 l20
</span><span>#1b1f7000 67 28 16 62 00 00 00 8a-67 58 c8 11 00 00 00 8a g(.b....gX......
</span><span>#1b1f7010 00 00 00 00 00 00 00 00-67 f8 40 77 00 00 00 8a ........g.@w....
</span></code></pre><p>Same data, the VA to PA conversion was successful, and the recursive page entries always point to the same PML4 table, at the physical address 0x1b1f7000. It all goes full circle, pretty nice.<p>Last, one can ask: is there any kind of randomization of the allocation of the physical pages themselves? Legit question, and I experimented using some LINQ querying:<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>kd> dx -g @$cursession.Processes.Select( p => new { ProcessName = p.Name, Pml4Base = p.KernelObject.Pcb.DirectoryTableBase & 0xfffffffffff000})
</span></code></pre><p>Across several reboots in my VM labs, only 2 matches are shown consistently<ul><li>Windows 2004 x64 Generation 1 (i.e. BIOS)</ul><table><thead><tr><th style=text-align:center>PID<th style=text-align:center>Process Name<th style=text-align:center>Pml4Base<tbody><tr><td style=text-align:center>0x0<td style=text-align:center>Idle<td style=text-align:center>0x1aa000<tr><td style=text-align:center>0x4<td style=text-align:center>System<td style=text-align:center>0x1aa000</table><ul><li>Windows 2004 x64 Generation 2 (i.e. UEFI)</ul><table><thead><tr><th style=text-align:center>PID<th style=text-align:center>Process Name<th style=text-align:center>Pml4Base<tbody><tr><td style=text-align:center>0x0<td style=text-align:center>Idle<td style=text-align:center>0x6d4000<tr><td style=text-align:center>0x4<td style=text-align:center>System<td style=text-align:center>0x6d4000</table><p>0x1aa000 for the physical address of a Gen1 (BIOS) Hyper-V VM, and 0x6d4000 for a Gen2 (UEFI). This seems to partially coincide with what was said in Ricerca‚Äôs article (see <a href=https://blahcat.github.io/2020-06-15-playing-with-self-reference-pml4-entry/#links>#1</a>) about the fact that the PML4 for System is at unrandomized physical address in most cases. From my limited testing the following physical addresses were found consistently (for Windows 2004 x64 with Kd):<table><thead><tr><th style=text-align:center>Platform<th style=text-align:center>PML4 Base<tbody><tr><td style=text-align:center>Native (UEFI)<td style=text-align:center>0x1ba000<tr><td style=text-align:center>Hyper-V Gen1 (BIOS)<td style=text-align:center>0x1aa000<tr><td style=text-align:center>Hyper-V Gen2 (UEFI)<td style=text-align:center>0x6d4000<tr><td style=text-align:center>VirtualBox (BIOS)<td style=text-align:center>0x1aa000<tr><td style=text-align:center>VirtualBox (UEFI)<td style=text-align:center>0x1ad000</table><div class=alert-info markdown=span><b class=markdown-alert-title> <svg class="octicon octicon-info mr-2" viewbox="0 0 16 16" aria-hidden=true height=16 version=1.1 width=16><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg> Note </b><p><p>if you have other values on your environment (Qemu, VMware), feel free to contact me and I‚Äôll update the table with the result of the KD command</div><pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>dx @$cursession.Processes.Where( p => p.Name == "System").First().KernelObject.Pcb.DirectoryTableBase & ~0xfff
</span></code></pre><p>And this is really the subtlety of Ricerca‚Äôs exploit: they showed that only with a fixed physical address (associated to the SYSTEM process), and a fixed virtual area (the <code>nt!_KUSER_SHARED_DATA</code> section at 0xfffff780`00000000) that is always at a known location since NT4, one can create an <abbr title="Memory Descriptor List">MDL</abbr> used in Direct Memory Access, and achieve arbitrary read to virtual addresses simply by recursing through the PML4E, the PDPTE, etc. just like the <abbr title="Memory Management Unit">MDL</abbr> does. Since they could read the PML4 entirely at a fixed physical address, say 0x1aa000, they could determine the index of the ‚ÄúSelf-Reference Entry‚Äù from a simple for-loop going through the PML4 page (very approximate pseudo-code):<pre class=language-python data-lang=python style=color:#c0c5ce;background-color:#2b303b><code class=language-python data-lang=python><span>system_pml4_root = </span><span style=color:#d08770>0x1aa000
</span><span>size_of_page = </span><span style=color:#d08770>0x1000
</span><span>size_of_entry = </span><span style=color:#d08770>8
</span><span>
</span><span style=color:#65737e># loop in the PML4
</span><span style=color:#b48ead>for </span><span>index </span><span style=color:#b48ead>in </span><span style=color:#96b5b4>range</span><span>(system_pml4_root, system_pml4_root+size_of_page, size_of_entry):
</span><span>  </span><span style=color:#65737e># get the entry
</span><span>  entry = </span><span style=color:#bf616a>u64</span><span>( </span><span style=color:#bf616a>read_physical_memory</span><span>(index) )
</span><span>  </span><span style=color:#65737e># compare to the root (after trimming the 12 lsb)
</span><span>  </span><span style=color:#b48ead>if </span><span>(entry >> </span><span style=color:#d08770>12</span><span>) == (system_pml4_root >> </span><span style=color:#d08770>12</span><span>):
</span><span>    </span><span style=color:#96b5b4>print</span><span>("</span><span style=color:#a3be8c>self-reference entry is at index: </span><span style=color:#d08770>%d</span><span>" % index)
</span></code></pre><p>I hope not to make it sound simple, it is not and took me quite some time to figure out, so massive props to <a class="fab fa-twitter" href="https://twitter.com/hugeh0ge`](https://twitter.com/hugeh0ge) and [`@_N4NU_" target=_blank> <code>@hugeh0ge`](https://twitter.com/hugeh0ge) and [`@_N4NU_</code> </a> for the implementation. This technique provides a somewhat reliable way to defeat KASLR, SMEP & SMAP with no other vulnerability, but by mere knowledge of Intel processors and Windows memory management inner workings, for the vulnerability CVE-2020-0796, which, due to Microsoft‚Äôs effort, made it tough.<p>Thanks for reading‚Ä¶‚úå<p><em>Update</em>: A <code>@$selfref()</code> function was added to <code>PageExplorer.js</code>, allowing to easily retrieve the PML4 self-reference (tested 8 -> 11)<pre class=language-txt data-lang=txt style=color:#c0c5ce;background-color:#2b303b><code class=language-txt data-lang=txt><span>0: kd> dx @$selfref()
</span><span>@$selfref()      : 0x1ec
</span><span>0: kd> dx @$ptview().pml4_table[ @$selfref() ].PhysicalPageAddress ==  @$ptview().pml4_table[ @$selfref() ].Children[ @$selfref() ].PhysicalPageAddress
</span><span>@$ptview().pml4_table[ @$selfref() ].PhysicalPageAddress ==  @$ptview().pml4_table[ @$selfref() ].Children[ @$selfref() ].PhysicalPageAddress : true
</span><span>0: kd> dx @$ptview().pml4_table[ @$selfref() ]
</span><span>@$ptview().pml4_table[ @$selfref() ]                 : PML4 Entry(PA=7d5000, Flags=[P RW K - - A D - -])
</span><span>    address          : 0x7d5f60
</span><span>    value            : 0x80000000007d5063
</span><span>    Flags            : Flags=[P RW K - - A D - -]
</span><span>    PageFrameNumber  : 0x7d5
</span><span>    Pfn              [Type: _MMPFN]
</span><span>    PhysicalPageAddress : 0x7d5000
</span><span>    Pte              : 0xfffff67b3d9ecf60 [Type: _MMPTE *]
</span><span>    Level            : PML4
</span><span>    Children
</span></code></pre><h1 id=links>Links</h1><p>What started picking my curiosity:<ul><li>[1] <a rel="noopener nofollow noreferrer" href=https://ricercasecurity.blogspot.com/2020/04/ill-ask-your-body-smbghost-pre-auth-rce.html target=_blank>Ricerca Security on exploiting the same bug</a><li>[2] <a rel="noopener nofollow noreferrer" href=https://github.com/chompie1337/SMBGhost_RCE_PoC/blob/master/exploit.py target=_blank>Chompie1337‚Äôs CVE-2020-0796 exploit</a></ul><p>The whole series of ‚Äú Getting Physical: Extreme abuse of Intel based Paging Systems‚Äú by N. Economou & E. Nissim (CoreSecurity) is a must read/watch:<ul><li>CoreSecurity Getting Physical: <a href="https://www.youtube.com/watch?v=QGf0-jHFulg&vl=en" rel="noopener nofollow noreferrer" target=_blank>The talk (es)</a> // <a rel="noopener nofollow noreferrer" href=http://docplayer.net/44469150-Windows-smep-bypass-u-s-nicolas-a-economou-enrique-e-nissim-p-a-g-e.html target=_blank>The slides</a><li><a rel="noopener nofollow noreferrer" href=https://www.coresecurity.com/core-labs/articles/getting-physical-extreme-abuse-of-intel-based-paging-systems-part-2-windows target=_blank>Part 2 - Windows</a><li><a rel="noopener nofollow noreferrer" href=https://www.coresecurity.com/core-labs/articles/getting-physical-extreme-abuse-of-intel-based-paging-systems target=_blank>Part 3 - Windows HAL‚Äôs Heap</a></ul><p>Other useful resources:<ul><li>[3] <a rel="noopener nofollow noreferrer" href=https://www.amazon.com/What-Makes-Page-Windows-Virtual/dp/1479114294 target=_blank>‚ÄúWhat Makes It Page? The Windows 7 x64 Virtual Memory Manager‚Äù - M. Martignetti</a><li><a href="https://www.youtube.com/watch?v=7zTtVYjjquA" rel="noopener nofollow noreferrer" target=_blank>‚ÄúGynvael‚Äôs Hacking Livestream #30: Windows Kernel Debugging Part III‚Äù - A. ‚Äúhonorary_bot‚Äù Shishkin</a><li><a rel="noopener nofollow noreferrer" href=https://labs.f-secure.com/archive/windows-8-kernel-memory-protections-bypass/ target=_blank>‚ÄúWindows 8 Kernel Memory Protections Bypass‚Äù - J. Fetiveau</a></ul><aside class=post-tags><p>Categories: <a href=https://blahcat.github.io/categories/research/>#research</a><p>Tags: <a href=https://blahcat.github.io/tags/windows/>#windows</a> <a href=https://blahcat.github.io/tags/kernel/>#kernel</a> <a href=https://blahcat.github.io/tags/mmu/>#mmu</a> <a href=https://blahcat.github.io/tags/x64/>#x64</a></aside><aside class=post-discussion>Join the Discussion on <a href="https://github.com/blahcat/blahcat.github.io/discussions?discussions_q=Some toying with the Self-Reference PML4 Entry" target=_blank> <i class="fab fa-github fa-lg"></i>¬†GitHub </a></aside><aside class=post-nav><div class=container><div class=row><div class=col><b>Next:</b><br><a class=post-nav-prev href=https://blahcat.github.io/2020-12-29-cheap-sandboxing-with-appcontainers/> <section class=post-nav-teaser><b class=post-nav-title>Cheap sandboxing with AppContainers</b><p class=post-nav-excerpt>Background This is a short blog post that I decided to finish recently afte‚Ä¶</section> </a></div><div class=col><b>Previous:</b><br><a class=post-nav-next href=https://blahcat.github.io/2020-05-23-enumerating-process-from-kd/> <section class=post-nav-teaser><b class=post-nav-title>Enumerating processes from KD</b><p class=post-nav-excerpt>This is tiny Post-It post to remind of different ways to enumerate processe‚Ä¶</section> </a></div></div></div></aside></div></div><hr><footer><div class=container><div class=row><div class="col-lg-8 col-md-10 mx-auto"><ul class="list-inline text-center"><li class=list-inline-item><a href=https://blahcat.github.io/atom.xml> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fas fa-rss fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://twitter.com/ctf_blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-twitter fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://github.com/blahcat> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-github fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://www.youtube.com/channel/UCDrgY65mRZWVoMiB5-VMqfg> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-youtube fa-stack-1x fa-inverse"></i> </span> </a><li class=list-inline-item><a href=https://discord.gg/hSbqxxBgRX> <span class="fa-stack fa-lg"> <i class="fas fa-circle fa-stack-2x"></i> <i class="fab fa-discord fa-stack-1x fa-inverse"></i> </span> </a></ul><p class="copyright text-muted">Made with ‚ù§ with Zola</div></div></div></footer><script src=https://blahcat.github.io/js/jquery.min.js></script><script src=https://blahcat.github.io/js/bootstrap.bundle.min.js></script><script src=https://blahcat.github.io/js/clean-blog.min.js></script><script src=//cdnjs.cloudflare.com/ajax/libs/mermaid/9.1.1/mermaid.min.js></script><div class=mermaidTooltip style=opacity:0></div>